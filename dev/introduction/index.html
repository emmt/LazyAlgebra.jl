<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lazy algebra framework · LazyAlgebra for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LazyAlgebra for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li class="is-active"><a class="tocitem" href>Lazy algebra framework</a><ul class="internal"><li><a class="tocitem" href="#Mappings"><span>Mappings</span></a></li><li><a class="tocitem" href="#Automatic-simplifications"><span>Automatic simplifications</span></a></li><li><a class="tocitem" href="#Creating-new-mappings"><span>Creating new mappings</span></a></li></ul></li><li><a class="tocitem" href="../vectors/">Methods for vectors</a></li><li><a class="tocitem" href="../sparse/">Sparse operators</a></li><li><a class="tocitem" href="../mappings/">Methods for mappings</a></li><li><a class="tocitem" href="../simplifications/">Simplification and optimization of combinations of mappings</a></li><li><a class="tocitem" href="../refs/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Lazy algebra framework</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lazy algebra framework</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LazyAlgebra.jl/blob/master/docs/src/introduction.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Lazy-algebra-framework"><a class="docs-heading-anchor" href="#Lazy-algebra-framework">Lazy algebra framework</a><a id="Lazy-algebra-framework-1"></a><a class="docs-heading-anchor-permalink" href="#Lazy-algebra-framework" title="Permalink"></a></h1><p><strong>LazyAlgebra</strong> is a <a href="http://julialang.org/">Julia</a> package to generalize the notion of matrices and vectors used in <a href="https://en.wikipedia.org/wiki/Linear_algebra">linear algebra</a>.</p><p>Many numerical methods (<em>e.g.</em> in numerical optimization or digital signal processing) involve essentially <a href="https://en.wikipedia.org/wiki/Vector_space">linear operations</a> on the considered variables.  LazyAlgebra provides a framework to implement these kind of numerical methods independently of the specific type of the variables. This is exploited in <a href="https://github.com/emmt/OptimPackNextGen.jl">OptimPackNextGen</a> package, an attempt to provide most optimization algorithms of <a href="https://github.com/emmt/OptimPack">OptimPack</a> in pure Julia.</p><p>LazyAlgebra also provides a flexible and extensible framework for creating complex mappings and linear mappings to operate on the variables.</p><p>A few concepts are central to LazyAlgebra:</p><ul><li><em>vectors</em> represent the variables of interest and can be anything providing a few methods are implemented for their specific type;</li><li><em>mappings</em> are any functions between such vectors;</li><li><em>linear mappings</em> (a.k.a. linear operators) behave linearly with respect to their arguments.</li></ul><p>There are several reasons to have special methods for basic vector operations rather than relying on Julia linear algebra methods.  First, the notion of <em>vector</em> is different, in Julia a mono-dimensional array is a vector while, here any object with embedded values can be assumed to be a vector providing a subset of methods are specialized for this type of object.  For instance, LazyAlgebra provides such methods specialized for real-valued and complex-valued (with real components) arrays of any dimensionality.  Second, the meaning of the methods may have to be different.  For instance, only real-valued functions can be minimized (or maximized) and for this task, complex-valued variables can just be considered as real-valued variables (each complex value being equivalent to a pair of reals).</p><h2 id="Mappings"><a class="docs-heading-anchor" href="#Mappings">Mappings</a><a id="Mappings-1"></a><a class="docs-heading-anchor-permalink" href="#Mappings" title="Permalink"></a></h2><p>LazyAlgebra features:</p><ul><li>flexible and extensible framework for creating complex mappings;</li><li><em>lazy</em> evaluation of the mappings;</li><li><em>lazy</em> assumptions when combining mappings;</li><li>efficient memory allocation by avoiding temporaries.</li></ul><h3 id="General-mappings"><a class="docs-heading-anchor" href="#General-mappings">General mappings</a><a id="General-mappings-1"></a><a class="docs-heading-anchor-permalink" href="#General-mappings" title="Permalink"></a></h3><p>A <code>Mapping</code> can be any function between two variables spaces.  Using Householder-like notation (that is upper case Latin letters denote <em>mappings</em>, lower case Latin letters denote <em>variables</em>, and Greek letters denote <em>scalars</em>), then:</p><ul><li><p><code>A(x)</code>, <code>A*x</code> or <code>A⋅x</code> yields the result of applying the mapping <code>A</code> to <code>x</code>;</p></li><li><p><code>A\x</code> yields the result of applying the inverse of <code>A</code> to <code>x</code>;</p></li></ul><p>Simple constructions are allowed for any kind of mappings and can be used to create new instances of mappings which behave correctly.  For instance:</p><ul><li><p><code>B = α*A</code> (where <code>α</code> is a number) is a mapping which behaves as <code>A</code> times <code>α</code>; that is <code>B(x)</code> yields the same result as <code>α*(A(x))</code>.</p></li><li><p><code>C = A + B + ...</code> is a mapping which behaves as the sum of the mappings <code>A</code>, <code>B</code>, ...; that is <code>C(x)</code> yields the same result as <code>A(x) + B(x) + ...</code>.</p></li><li><p><code>C = A*B</code>, <code>C = A∘B</code> or <code>C = A⋅B</code> is a mapping which behaves as the composition of the mappings <code>A</code> and <code>B</code>; that is <code>C⋅x</code> yields the same result as <code>A(B(x))</code>.  As for the sum of mappings, there may be an arbitrary number of mappings in a composition; for example, if <code>D = A*B*C</code> then <code>D(x)</code> yields the same result as <code>A(B(C(x)))</code>.</p></li><li><p><code>C = A\B</code> is a mapping such that <code>C(x)</code> yields the same result as <code>inv(A)(B(x))</code>.</p></li><li><p><code>C = A/B</code> is a mapping such that <code>C(x)</code> yields the same result as <code>A(inv(B)(x))</code>.</p></li></ul><p>These constructions can be combined to build up more complex mappings.  For example:</p><ul><li><code>D = A*(B + 3C)</code> is a mapping such that <code>D⋅x</code> yields the same result as <code>A(B(x) + 3*C(x))</code>.</li></ul><h3 id="Linear-mappings"><a class="docs-heading-anchor" href="#Linear-mappings">Linear mappings</a><a id="Linear-mappings-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-mappings" title="Permalink"></a></h3><p>A <code>LinearMapping</code> can be any linear mapping between two spaces.  This abstract subtype of <code>Mapping</code> is introduced to extend the notion of <em>matrices</em> and <em>vectors</em>.  Assuming the type of <code>A</code> inherits from <code>LinearMapping</code>, then:</p><ul><li><p>for linear mappings <code>A</code> and <code>B</code>, <code>A⋅B</code> is the same as <code>A∘B</code> or <code>A*B</code> which yields the composition of <code>A</code> and <code>B</code> whose effect is to apply <code>B</code> and then <code>A</code>;</p></li><li><p><code>A&#39;⋅x</code> and <code>A&#39;*x</code> yields the result of applying the adjoint of the mapping <code>A</code> to <code>x</code>;</p></li><li><p><code>A&#39;\x</code> yields the result of applying the adjoint of the inverse of mapping <code>A</code> to <code>x</code>.</p></li><li><p><code>B = A&#39;</code> is a mapping such that <code>B⋅x</code> yields the same result as <code>A&#39;⋅x</code>.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Beware that, due to the priority of operators in Julia, <code>A*B(x)</code> is the same as <code>A(B(x))</code> not <code>(A*B)(x)</code>.</p></div></div><h2 id="Automatic-simplifications"><a class="docs-heading-anchor" href="#Automatic-simplifications">Automatic simplifications</a><a id="Automatic-simplifications-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-simplifications" title="Permalink"></a></h2><p>An important feature of LazyAlgebra framework for mappings is that a <em>number of simplifications are automatically made at contruction time</em>.  For instance, assuming <code>A</code> is a mapping:</p><pre><code class="language-julia">B = A&#39;
C = B&#39;</code></pre><p>yields <code>C</code> which is just a reference to <code>A</code>. In other words, <code>adjoint(adjoint(A)) -&gt; A</code> holds.  Likely</p><pre><code class="language-julia">D = inv(A)
E = inv(D)</code></pre><p>yields <code>E</code> which is another reference to <code>A</code>.  In other words, <code>inv(inv(A)) -&gt; A</code> holds assuming by default that <code>A</code> is invertible.  This follows the principles of laziness.  It is however, possible to prevent this by extending the <code>Base.inv</code> method so as to throw an exception when applied to the specific type of <code>A</code>:</p><pre><code class="language-julia">Base.inv(::SomeNonInvertibleMapping) = error(&quot;non-invertible mapping&quot;)</code></pre><p>where <code>SomeNonInvertibleMapping &lt;: Mapping</code> is the type of <code>A</code>.</p><p>Other example of simplifications:</p><pre><code class="language-julia">B = 3A
C = 7B&#39;</code></pre><p>where mappings <code>B</code> and <code>C</code> are such that <code>B*x -&gt; 3*(A*x)</code> and <code>C*x -&gt; 21*(A*x)</code> for any <em>vector</em> <code>x</code>.  That is <code>C*x</code> is evaluated as <code>21*(A*x)</code> not as <code>7*(3*(A*x))</code> thanks to simplifications occurring while the mapping <code>C</code> is constructed.</p><p>Using the <code>-&gt;</code> to denote in the right-hand side the actual construction made by LazyAlgebra for the expression in the left-hand side and assuming <code>A</code>, <code>B</code> and <code>C</code> are linear mappings, the following simplications will occur:</p><pre><code class="language-julia">(A + C + B + 3C)&#39; -&gt; A&#39; + B&#39; + 4C&#39;
(A*B*3C)&#39;         -&gt; 3C&#39;*B&#39;*A&#39;
inv(A*B*3C)       -&gt; 3\inv(C)*inv(B)*inv(A)</code></pre><p>However, if <code>M</code> is a non-linear mapping, then:</p><pre><code class="language-julia">inv(A*B*3M) -&gt; inv(M)*(3\inv(B))*inv(A)</code></pre><p>which can be compared to <code>inv(A*B*3C)</code> when all operands are linear mappings.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Due to the associative rules applied by Julia, parentheses are needed around constructions like <code>3*C</code> if it has to be interpreted as <code>3C</code> in all contexes.  Otherwise, <code>A*B*(3*C)</code> is equivalent to <code>A*B*3C</code> while <code>A*B*3*C</code> is interpreted as <code>((A*B)*3)*C</code>; that is, compose <code>A</code> and <code>B</code>, apply <code>A*B</code> to <code>3</code> and right multiply the result by <code>C</code>.</p></div></div><h2 id="Creating-new-mappings"><a class="docs-heading-anchor" href="#Creating-new-mappings">Creating new mappings</a><a id="Creating-new-mappings-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-new-mappings" title="Permalink"></a></h2><p>LazyAlgebra provides a number of simple mappings.  Creating new primitive mapping types (not by combining existing mappings as explained above) which benefit from the LazyAlgebra framework is as simple as declaring a new mapping subtype of <code>Mapping</code> (or one of its abstract subtypes) and extending two methods <code>vcreate</code> and <code>apply!</code> specialized for the new mapping type.  For mode details, see <a href="../mappings/">here</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../install/">« Installation</a><a class="docs-footer-nextpage" href="../vectors/">Methods for vectors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 10 May 2021 10:25">Monday 10 May 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
