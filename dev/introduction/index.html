<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lazy algebra framework · LazyAlgebra for Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LazyAlgebra for Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../install/">Installation</a></li><li class="current"><a class="toctext" href>Lazy algebra framework</a><ul class="internal"><li><a class="toctext" href="#Mappings-1">Mappings</a></li><li><a class="toctext" href="#Automatic-simplifications-1">Automatic simplifications</a></li><li><a class="toctext" href="#Creating-new-mappings-1">Creating new mappings</a></li></ul></li><li><a class="toctext" href="../vectors/">Methods for vectors</a></li><li><a class="toctext" href="../mappings/">Methods for mappings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Lazy algebra framework</a></li></ul><a class="edit-page" href="https://github.com/emmt/LazyAlgebra.jl/blob/master/docs/src/introduction.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Lazy algebra framework</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Lazy-algebra-framework-1" href="#Lazy-algebra-framework-1">Lazy algebra framework</a></h1><p><strong>LazyAlgebra</strong> is a <a href="http://julialang.org/">Julia</a> package to generalize the notion of matrices and vectors used in <a href="https://en.wikipedia.org/wiki/Linear_algebra">linear algebra</a>.</p><p>Many numerical methods (<em>e.g.</em> in numerical optimization or digital signal processing) involve essentially <a href="https://en.wikipedia.org/wiki/Vector_space">linear operations</a> on the considered variables.  LazyAlgebra provides a framework to implement these kind of numerical methods independently of the specific type of the variables. This is exploited in <a href="https://github.com/emmt/OptimPackNextGen.jl">OptimPackNextGen</a> package, an attempt to provide most optimization algorithms of <a href="https://github.com/emmt/OptimPack">OptimPack</a> in pure Julia.</p><p>LazyAlgebra also provides a flexible and extensible framework for creating complex mappings and linear mappings to operate on the variables.</p><p>A few concepts are central to LazyAlgebra:</p><ul><li><em>vectors</em> represent the variables of interest and can be anything providing a few methods are implemented for their specific type;</li><li><em>mappings</em> are any functions between such vectors;</li><li><em>linear mappings</em> (a.k.a. linear operators) behave linearly with respect to their arguments.</li></ul><p>There are several reasons to have special methods for basic vector operations rather than relying on Julia linear algebra methods.  First, the notion of <em>vector</em> is different, in Julia a mono-dimensional array is a vector while, here any object with embedded values can be assumed to be a vector providing a subset of methods are specialized for this type of object.  For instance, LazyAlgebra provides such methods specialized for real-valued and complex-valued (with real components) arrays of any dimensionality.  Second, the meaning of the methods may have to be different.  For instance, only real-valued functions can be minimized (or maximized) and for this task, complex-valued variables can just be considered as real-valued variables (each complex value being equivalent to a pair of reals).</p><h2><a class="nav-anchor" id="Mappings-1" href="#Mappings-1">Mappings</a></h2><p>LazyAlgebra features:</p><ul><li>flexible and extensible framework for creating complex mappings;</li><li><em>lazy</em> evaluation of the mappings;</li><li><em>lazy</em> assumptions when combining mappings;</li><li>efficient memory allocation by avoiding temporaries.</li></ul><h3><a class="nav-anchor" id="General-mappings-1" href="#General-mappings-1">General mappings</a></h3><p>A <code>Mapping</code> can be any function between two variables spaces.  Using Householder-like notation (that is upper case Latin letters denote <em>mappings</em>, lower case Latin letters denote <em>variables</em>, and Greek letters denote <em>scalars</em>), then:</p><ul><li><p><code>A(x)</code>, <code>A*x</code> or <code>A⋅x</code> yields the result of applying the mapping <code>A</code> to <code>x</code>;</p></li><li><p><code>A\x</code> yields the result of applying the inverse of <code>A</code> to <code>x</code>;</p></li></ul><p>Simple constructions are allowed for any kind of mappings and can be used to create new instances of mappings which behave correctly.  For instance:</p><ul><li><p><code>B = α*A</code> (where <code>α</code> is a number) is a mapping which behaves as <code>A</code> times <code>α</code>; that is <code>B(x)</code> yields the same result as <code>α*(A(x))</code>.</p></li><li><p><code>C = A + B + ...</code> is a mapping which behaves as the sum of the mappings <code>A</code>, <code>B</code>, ...; that is <code>C(x)</code> yields the same result as <code>A(x) + B(x) + ...</code>.</p></li><li><p><code>C = A*B</code>, <code>C = A∘B</code> or <code>C = A⋅B</code> is a mapping which behaves as the composition of the mappings <code>A</code> and <code>B</code>; that is <code>C⋅x</code> yields the same result as <code>A(B(x))</code>.  As for the sum of mappings, there may be an arbitrary number of mappings in a composition; for example, if <code>D = A*B*C</code> then <code>D(x)</code> yields the same result as <code>A(B(C(x)))</code>.</p></li><li><p><code>C = A\B</code> is a mapping such that <code>C(x)</code> yields the same result as <code>inv(A)(B(x))</code>.</p></li><li><p><code>C = A/B</code> is a mapping such that <code>C(x)</code> yields the same result as <code>A(inv(B)(x))</code>.</p></li></ul><p>These constructions can be combined to build up more complex mappings.  For example:</p><ul><li><code>D = A*(B + 3C)</code> is a mapping such that <code>D⋅x</code> yields the same result as <code>A(B(x) + 3*C(x))</code>.</li></ul><h3><a class="nav-anchor" id="Linear-mappings-1" href="#Linear-mappings-1">Linear mappings</a></h3><p>A <code>LinearMapping</code> can be any linear mapping between two spaces.  This abstract subtype of <code>Mapping</code> is introduced to extend the notion of <em>matrices</em> and <em>vectors</em>.  Assuming the type of <code>A</code> inherits from <code>LinearMapping</code>, then:</p><ul><li><p>for linear mappings <code>A</code> and <code>B</code>, <code>A⋅B</code> is the same as <code>A∘B</code> or <code>A*B</code> which yields the composition of <code>A</code> and <code>B</code> whose effect is to apply <code>B</code> and then <code>A</code>;</p></li><li><p><code>A&#39;⋅x</code> and <code>A&#39;*x</code> yields the result of applying the adjoint of the mapping <code>A</code> to <code>x</code>;</p></li><li><p><code>A&#39;\x</code> yields the result of applying the adjoint of the inverse of mapping <code>A</code> to <code>x</code>.</p></li><li><p><code>B = A&#39;</code> is a mapping such that <code>B⋅x</code> yields the same result as <code>A&#39;⋅x</code>.</p></li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Beware that, due to the priority of operators in Julia, <code>A*B(x)</code> is the same as <code>A(B(x))</code> not <code>(A*B)(x)</code>.</p></div></div><h2><a class="nav-anchor" id="Automatic-simplifications-1" href="#Automatic-simplifications-1">Automatic simplifications</a></h2><p>An important feature of LazyAlgebra framework for mappings is that a <em>number of simplifications are automatically made at contruction time</em>.  For instance, assuming <code>A</code> is a mapping:</p><pre><code class="language-julia">B = A&#39;
C = B&#39;</code></pre><p>yields <code>C</code> which is just a reference to <code>A</code>. In other words, <code>adjoint(adjoint(A)) -&gt; A</code> holds.  Likely</p><pre><code class="language-julia">D = inv(A)
E = inv(D)</code></pre><p>yields <code>E</code> which is another reference to <code>A</code>.  In other words, <code>inv(inv(A)) -&gt; A</code> holds assuming by default that <code>A</code> is invertible.  This follows the principles of laziness.  It is however, possible to prevent this by extending the <code>Base.inv</code> method so as to throw an exception when applied to the specific type of <code>A</code>:</p><pre><code class="language-julia">Base.inv(::SomeNonInvertibleMapping) = error(&quot;non-invertible mapping&quot;)</code></pre><p>where <code>SomeNonInvertibleMapping &lt;: Mapping</code> is the type of <code>A</code>.</p><p>Other example of simplifications:</p><pre><code class="language-julia">B = 3A
C = 7B&#39;</code></pre><p>where mappings <code>B</code> and <code>C</code> are such that <code>B*x ≡ 3*(A*x)</code> and <code>C*x ≡ 21*(A*x)</code> for any <em>vector</em> <code>x</code>.  That is <code>C*x</code> is evaluated as <code>21*(A*x)</code> not as <code>7*(3*(A*x))</code> thanks to simplifications occurring while the mapping <code>C</code> is constructed.</p><p>Using the <code>≡</code> to denote in the right-hand side the actual construction made by LazyAlgebra for the expression in the left-hand side and assuming <code>A</code>, <code>B</code> and <code>C</code> are linear mappings, the following simplications will occur:</p><pre><code class="language-julia">(A + C + B + 3C)&#39; ≡ A&#39; + B&#39; + 4C&#39;
(A*B*3C)&#39;         ≡ 3C&#39;*B&#39;*A&#39;
inv(A*B*3C)       ≡ 3\inv(C)*inv(B)*inv(A)</code></pre><p>However, if <code>M</code> is a non-linear mapping, then:</p><pre><code class="language-julia">inv(A*B*3M) ≡ inv(M)*(3\inv(B))*inv(A)</code></pre><p>which can be compared to <code>inv(A*B*3C)</code> when all operands are linear mappings.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Due to the associative rules applied by Julia, parentheses are needed around constructions like <code>3*C</code> if it has to be interpreted as <code>3C</code> in all contexes.  Otherwise, <code>A*B*(3*C)</code> is equivalent to <code>A*B*3C</code> while <code>A*B*3*C</code> is interpreted as <code>((A*B)*3)*C</code>; that is, compose <code>A</code> and <code>B</code>, apply <code>A*B</code> to <code>3</code> and right multiply the result by <code>C</code>.</p></div></div><h2><a class="nav-anchor" id="Creating-new-mappings-1" href="#Creating-new-mappings-1">Creating new mappings</a></h2><p>LazyAlgebra provides a number of simple mappings.  Creating new primitive mapping types (not by combining existing mappings as explained above) which benefit from the LazyAlgebra framework is as simple as declaring a new mapping subtype of <code>Mapping</code> (or one of its abstract subtypes) and extending two methods <code>vcreate</code> and <code>apply!</code> specialized for the new mapping type.  For mode details, see <a href="../mappings/">here</a>.</p><footer><hr/><a class="previous" href="../install/"><span class="direction">Previous</span><span class="title">Installation</span></a><a class="next" href="../vectors/"><span class="direction">Next</span><span class="title">Methods for vectors</span></a></footer></article></body></html>
