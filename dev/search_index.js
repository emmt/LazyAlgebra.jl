var documenterSearchIndex = {"docs":
[{"location":"mappings/#Methods-for-mappings","page":"Methods for mappings","title":"Methods for mappings","text":"","category":"section"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"LazyAlgebra provides a number of mappings and linear operators.  To create new primitive mapping types (not by combining existing mappings) and benefit from the LazyAlgebra infrastruture, you have to:","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"Create a new type derived from Mapping or one of its abstract sub-types such as LinearMapping.\nImplement at least two methods apply! and vcreate specialized for the new mapping type.  Applying the mapping is done by the former method.  The latter method is called to create a new output variable suitable to store the result of applying the mapping (or one of its variants) to some input variable.\nOptionally specialize method identical for two arguments of the new mapping type.","category":"page"},{"location":"mappings/#The-vcreate-method","page":"Methods for mappings","title":"The vcreate method","text":"","category":"section"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"The signature of the vcreate method to be implemented by specific mapping types is:","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"vcreate(::Type{P}, A::Ta, x::Tx, scratch::Bool) -> y","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"where A is the mapping, x its argument and P is one of Direct, Adjoint, Inverse and/or InverseAdjoint (or equivalently AdjointInverse) and indicates how A is to be applied:","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"Direct to apply A to x, e.g. to compute A⋅x;\nAdjoint to apply the adjoint of A to x, e.g. to compute A'⋅x;\nInverse to apply the inverse of A to x, e.g. to compute A\\x;\nInverseAdjoint or AdjointInverse to apply the inverse of A' to x, e.g. to compute A'\\x.","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"The result returned by vcreate is a new output variables suitable to store the result of applying the mapping A (or one of its variants as indicated by P) to the input variables x.","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"The scratch argument is a boolean to let the caller indicate whether the input variable x may be re-used to store the result.  If scratch is true and if that make sense, the value returned by vcreate may be x.  Calling vcreate with scratch=true can be used to limit the allocation of resources when possible.  Having scratch=true is only indicative and a specific implementation of vcreate may legitimately always assume scratch=false and return a new variable whatever the value of this argument (e.g. because applying the considered mapping in-place is not possible or because the considered mapping is not an endomorphism).  Of course, the opposite behavior (i.e., assuming that scratch=true while the method was called with scratch=false) is forbidden.","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"The result returned by vcreate should be of predictible type to ensure type-stability.  Checking the validity (e.g. the size) of argument x in vcreate may be skipped because this argument will be eventually checked by the apply! method.","category":"page"},{"location":"mappings/#The-apply!-method","page":"Methods for mappings","title":"The apply! method","text":"","category":"section"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"The signature of the apply! method to be implemented by specific mapping types is:","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"apply!(α::Number, ::Type{P}, A::Ta, x::Tx, scratch::Bool, β::Number, y::Ty) -> y","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"This method shall overwrites the contents of output variables y with the result of α*P(A)⋅x + β*y where P is one of Direct, Adjoint, Inverse and/or InverseAdjoint (or equivalently AdjointInverse) and shall return y.  The convention is that the prior contents of y is not used at all if β = 0 so the contents of y does not need to be initialized in that case.","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"Not all operations P must be implemented, only the supported ones.  For iterative resolution of (inverse) problems, it is generally needed to implement at least the Direct and Adjoint operations for linear operators.  However nonlinear mappings are not supposed to implement the Adjoint and derived operations.","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"Argument scratch is a boolean to let the caller indicate whether the contents of the input variable x may be overwritten during the operations.  If scratch=false, the apply! method shall not modify the contents of x.","category":"page"},{"location":"mappings/#The-identical-method","page":"Methods for mappings","title":"The identical method","text":"","category":"section"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"The method identical(A,B) yields whether A and B are the same mappings in the sense that their effects will always be the same.  This method is used to perform some simplifications and optimizations and may have to be specialized for specific mapping types.  The default implementation is to return A === B.","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"The returned result may be true although A and B are not necessarily the same object.  In the below example, if A and B are two sparse matrices whose coefficients and indices are stored in the same vectors (as can be tested with the === operator) this method should return true because the two operators will behave identically (any changes in the coefficients or indices of A will be reflected in B).  If any of the vectors storing the coefficients or the indices are not the same objects, then identical(A,B) must return false even though the stored values may be the same because it is possible, later, to change one operator without affecting identically the other.","category":"page"},{"location":"mappings/#Example","page":"Methods for mappings","title":"Example","text":"","category":"section"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"The following example implements a simple sparse linear operator which is able to operate on multi-dimensional arrays (the so-called variables):","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"# Use LazyAlgebra framework and import methods that need to be extended.\nusing LazyAlgebra\nimport LazyAlgebra: vcreate, apply!, input_size, output_size\n\nstruct SparseOperator{T<:AbstractFloat,M,N} <: LinearMapping\n    outdims::NTuple{M,Int}\n    inpdims::NTuple{N,Int}\n    A::Vector{T}\n    I::Vector{Int}\n    J::Vector{Int}\nend\n\ninput_size(S::SparseOperator) = S.inpdims\noutput_size(S::SparseOperator) = S.outdims\n\nfunction vcreate(::Type{Direct}, S::SparseOperator{Ts,M,N},\n                 x::DenseArray{Tx,N},\n                 scratch::Bool) where {Ts<:Real,Tx<:Real,M,N}\n    @assert size(x) == input_size(S)\n    Ty = promote_type(Ts, Tx)\n    return Array{Ty}(undef, output_size(S))\nend\n\nfunction vcreate(::Type{Adjoint}, S::SparseOperator{Ts,M,N},\n                 x::DenseArray{Tx,M},\n                 scratch::Bool) where {Ts<:Real,Tx<:Real,M,N}\n    @assert size(x) == output_size(S)\n    Ty = promote_type(Ts, Tx)\n    return Array{Ty}(undef, input_size(S))\nend\n\nfunction apply!(α::Real,\n                ::Type{Direct},\n                S::SparseOperator{Ts,M,N},\n                x::DenseArray{Tx,N},\n                scratch::Bool,\n                β::Real,\n                y::DenseArray{Ty,M}) where {Ts<:Real,Tx<:Real,Ty<:Real,M,N}\n    @assert size(x) == input_size(S)\n    @assert size(y) == output_size(S)\n    β == 1 || vscale!(y, β)\n    if α != 0\n        A, I, J = S.A, S.I, S.J\n        alpha = convert(promote_type(Ts,Tx,Ty), α)\n        @assert length(I) == length(J) == length(A)\n        for k in 1:length(A)\n            i, j = I[k], J[k]\n            y[i] += alpha*A[k]*x[j]\n        end\n    end\n    return y\nend\n\nfunction apply!(α::Real,\n                ::Type{Adjoint},\n                S::SparseOperator{Ts,M,N},\n                x::DenseArray{Tx,M},\n                scratch::Bool,\n                β::Real,\n                y::DenseArray{Ty,N}) where {Ts<:Real,Tx<:Real,Ty<:Real,M,N}\n    @assert size(x) == output_size(S)\n    @assert size(y) == input_size(S)\n    β == 1 || vscale!(y, β)\n    if α != 0\n        A, I, J = S.A, S.I, S.J\n        alpha = convert(promote_type(Ts,Tx,Ty), α)\n        @assert length(I) == length(J) == length(A)\n        for k in 1:length(A)\n            i, j = I[k], J[k]\n            y[j] += alpha*A[k]*x[i]\n        end\n    end\n    return y\nend\n\nidentical(A::T, B::T) where {T<:SparseOperator} =\n    (A.outdims == B.outdims && A.inpdims == B.inpdims &&\n     A.A === B.A && A.I === B.I && A.J === B.J)","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"Remarks:","category":"page"},{"location":"mappings/","page":"Methods for mappings","title":"Methods for mappings","text":"In our example, arrays are restricted to be dense so that linear indexing is efficient.  For the sake of clarity, the above code is intended to be correct although there are many possible optimizations.\nIf α = 0 there is nothing to do except scale y by β.\nThe call to vscale!(β, y) is to properly initialize y.  Remember the convention that the contents of y is not used at all if β = 0 so y does not need to be properly initialized in that case, it will simply be zero-filled by the call to vscale!.  The statements\nβ == 1 || vscale!(y, β)\nare equivalent to:\nif β != 1\n    vscale!(y, β)\nend\nwhich may be simplified to just calling vscale! unconditionally:\nvscale!(y, β)\nas vscale!(y, β) does nothing if β = 1.\n@inbounds could be used for the loops but this would require checking that all indices are whithin the bounds.  In this example, only k is guaranteed to be valid, i and j have to be checked.","category":"page"},{"location":"vectors/#Methods-for-vectors","page":"Methods for vectors","title":"Methods for vectors","text":"","category":"section"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"A vector is that which has the algebra of a vector space (Peano 1888, van der Waerden 1931).  See talk by Jiahao Chen: Taking Vector Transposes Seriously at JuliaCon 2017.","category":"page"},{"location":"vectors/#Vectorized-methods","page":"Methods for vectors","title":"Vectorized methods","text":"","category":"section"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"Most necessary operations on the variables of interest are linear operations. Hence variables (whatever their specific type and size) are just called vectors in LazyAlgebra.  Numerical methods based on LazyAlgebra manipulate the variables via a small number of vectorized methods:","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"vdot([T,][w,]x,y) yields the inner product of x and y; that is, the sum of conj(x[i])*y[i] or, if w is specified, the sum of w[i]*conj(x[i])*y[i], for all indices i.  Optional argument T is the type of the result; for real valued vectors, T is a floating-point type; for complex valued vectors, T can be a complex type (with floating-point parts) or a floating-point type to compute only the real part of the inner product.  vdot([T,]sel,x,y) yields the sum of x[i]*y[i] for all i ∈ sel where sel is a selection of indices.\nvnorm1([T,]x) yields the L-1 norm of x, that is the sum of the absolute values of the components of x.  Optional argument T is the floating-point type of the result.\nvnorm2([T,]x) yields the Euclidean (or L-2) norm of x, that is the square root of sum of the squared values of the components of x.  Optional argument T is the floating-point type of the result.\nvnorminf([T,]x) L-∞ norm of x, that is the maximal absolute values of the components of x.  Optional argument T is the floating-point type of the result\nvcreate(x) yields a new variable instance similar to x.  If x is an array, the element type of the result is a floating-point type.\nvcopy!(dst,src) copies the contents of src into dst and returns dst.\nvcopy(x) yields a fresh copy of the vector x.\nvswap!(x,y) exchanges the contents of x and y (which must have the same type and size if they are arrays).\nvfill!(x,α) sets all elements of x with the scalar value α and return x.\nvzero!(x)fills x with zeros and returns it.\nvscale!(dst,α,src) overwrites dst with α*src and returns dst.  The convention is that, if α = 0, then dst is filled with zeros whatever the contents of src.\nvscale!(x,α) and vscale!(α,x) overwrite x with α*x and returns x. The convention is that, if α = 0, then x is filled with zeros whatever its prior contents.\nvscale(α,x) and vscale(x,α) yield a new vector whose elements are those of x multiplied by the scalar α.\nvproduct!(dst,[sel,]x,y) overwrites dst with the elementwise multiplication of x by y.  Optional argument sel is a selection of indices to consider.\nvproduct(x,y) yields the elementwise multiplication of x by y.\nvupdate!(y,[sel,]α,x) overwrites y with α*x + y and returns y. Optional argument sel is a selection of indices to which apply the operation (if an index is repeated, the operation will be performed several times at this location).\nvcombine(α,x,β,y) yields the linear combination α*x or α*x + β*y.\nvcombine!(dst,α,x,β,y) overwrites dst with the linear combination dst = α*x or dst = α*x + β*y and returns dst.","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"Note that the names of these methods all start with a v (for vector) as the conventions used by these methods may be particular.  For instance, compared to copy! and when applied to arrays, vcopy! imposes that the two arguments have exactly the same dimensions.  Another example is the vdot method which has a slightly different semantics than Julia dot method.","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"LazyAlgebra already provides implementations of these methods for Julia arrays with floating-point type elements.  This implementation assumes that an array is a valid vector providing it has suitable type and dimensions.","category":"page"},{"location":"vectors/#Implementing-a-new-vector-type","page":"Methods for vectors","title":"Implementing a new vector type","text":"","category":"section"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"To have a numerical method based on LazyAlgebra be applicable to a new given type of variables, it is sufficient to implement a subset of these basic methods specialized for this kind of variables.","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"The various operations that should be implemented for a vector are:","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"compute the inner product of two vectors of the same kind (vdot(x,y) method);\ncreate a vector of a given kind (vcreate(x) method);\ncopy a vector (vcopy!(dst,src));\nfill a vector with a given value (vfill!(x,α) method);\nexchange the contents of two vectors (vswap!(x,y) method);\nlinearly combine several vectors (vcombine!(dst,α,x,β,y) method).","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"Derived methods are:","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"compute the Euclidean norm of a vector (vnorm2 method, based on vdot by default);\nmultiply a vector by a scalar: vscale!(dst,α,src) and/or vscale!(x,α) methods (based on vcombine! by default);\nupdate a vector by a scaled step: vupdate!(y,α,x) method (based on vcombine! by default) and, for some constrained optimization methods, vupdate!(y,sel,α,x) method;\nerase a vector: vzero!(x) method (based on vfill! by default);\nvscale and vcopy methods are implemented with vcreate and respectivelyvscale! and vcopy!.","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"Other methods which may be required by some packages:","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"compute the L-1 norm of a vector: vnorm1(x) method;\ncompute the L-∞ norm of a vector: vnorminf(x) method;","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"Methods that must be implemented (V represent the vector type):","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"vdot(x::V, y::V)","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"vscale!(dst::V, alpha::Real, src::V) -> dst","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"methods that may be implemented:","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"vscale!(alpha::Real, x::V) -> x","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"For mappings and linear operators (see Implementation of new mappings for details), implement:","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"apply!(α::Scalar, P::Type{<:Operations}, A::Ta, x::Tx, β::Scalar, y::Ty) -> y","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"and","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"vcreate(P::Type{P}, A::Ta, x::Tx) -> y","category":"page"},{"location":"vectors/","page":"Methods for vectors","title":"Methods for vectors","text":"for Ta<:Mapping and the supported operations P<:Operations.","category":"page"},{"location":"introduction/#Lazy-algebra-framework","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"","category":"section"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"LazyAlgebra is a Julia package to generalize the notion of matrices and vectors used in linear algebra.","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"Many numerical methods (e.g. in numerical optimization or digital signal processing) involve essentially linear operations on the considered variables.  LazyAlgebra provides a framework to implement these kind of numerical methods independently of the specific type of the variables. This is exploited in OptimPackNextGen package, an attempt to provide most optimization algorithms of OptimPack in pure Julia.","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"LazyAlgebra also provides a flexible and extensible framework for creating complex mappings and linear mappings to operate on the variables.","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"A few concepts are central to LazyAlgebra:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"vectors represent the variables of interest and can be anything providing a few methods are implemented for their specific type;\nmappings are any functions between such vectors;\nlinear mappings (a.k.a. linear operators) behave linearly with respect to their arguments.","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"There are several reasons to have special methods for basic vector operations rather than relying on Julia linear algebra methods.  First, the notion of vector is different, in Julia a mono-dimensional array is a vector while, here any object with embedded values can be assumed to be a vector providing a subset of methods are specialized for this type of object.  For instance, LazyAlgebra provides such methods specialized for real-valued and complex-valued (with real components) arrays of any dimensionality.  Second, the meaning of the methods may have to be different.  For instance, only real-valued functions can be minimized (or maximized) and for this task, complex-valued variables can just be considered as real-valued variables (each complex value being equivalent to a pair of reals).","category":"page"},{"location":"introduction/#Mappings","page":"Lazy algebra framework","title":"Mappings","text":"","category":"section"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"LazyAlgebra features:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"flexible and extensible framework for creating complex mappings;\nlazy evaluation of the mappings;\nlazy assumptions when combining mappings;\nefficient memory allocation by avoiding temporaries.","category":"page"},{"location":"introduction/#General-mappings","page":"Lazy algebra framework","title":"General mappings","text":"","category":"section"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"A Mapping can be any function between two variables spaces.  Using Householder-like notation (that is upper case Latin letters denote mappings, lower case Latin letters denote variables, and Greek letters denote scalars), then:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"A(x), A*x or A⋅x yields the result of applying the mapping A to x;\nA\\x yields the result of applying the inverse of A to x;","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"Simple constructions are allowed for any kind of mappings and can be used to create new instances of mappings which behave correctly.  For instance:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"B = α*A (where α is a number) is a mapping which behaves as A times α; that is B(x) yields the same result as α*(A(x)).\nC = A + B + ... is a mapping which behaves as the sum of the mappings A, B, ...; that is C(x) yields the same result as A(x) + B(x) + ....\nC = A*B, C = A∘B or C = A⋅B is a mapping which behaves as the composition of the mappings A and B; that is C⋅x yields the same result as A(B(x)).  As for the sum of mappings, there may be an arbitrary number of mappings in a composition; for example, if D = A*B*C then D(x) yields the same result as A(B(C(x))).\nC = A\\B is a mapping such that C(x) yields the same result as inv(A)(B(x)).\nC = A/B is a mapping such that C(x) yields the same result as A(inv(B)(x)).","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"These constructions can be combined to build up more complex mappings.  For example:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"D = A*(B + 3C) is a mapping such that D⋅x yields the same result as A(B(x) + 3*C(x)).","category":"page"},{"location":"introduction/#Linear-mappings","page":"Lazy algebra framework","title":"Linear mappings","text":"","category":"section"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"A LinearMapping can be any linear mapping between two spaces.  This abstract subtype of Mapping is introduced to extend the notion of matrices and vectors.  Assuming the type of A inherits from LinearMapping, then:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"for linear mappings A and B, A⋅B is the same as A∘B or A*B which yields the composition of A and B whose effect is to apply B and then A;\nA'⋅x and A'*x yields the result of applying the adjoint of the mapping A to x;\nA'\\x yields the result of applying the adjoint of the inverse of mapping A to x.\nB = A' is a mapping such that B⋅x yields the same result as A'⋅x.","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"note: Note\nBeware that, due to the priority of operators in Julia, A*B(x) is the same as A(B(x)) not (A*B)(x).","category":"page"},{"location":"introduction/#Automatic-simplifications","page":"Lazy algebra framework","title":"Automatic simplifications","text":"","category":"section"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"An important feature of LazyAlgebra framework for mappings is that a number of simplifications are automatically made at contruction time.  For instance, assuming A is a mapping:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"B = A'\nC = B'","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"yields C which is just a reference to A. In other words, adjoint(adjoint(A)) -> A holds.  Likely","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"D = inv(A)\nE = inv(D)","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"yields E which is another reference to A.  In other words, inv(inv(A)) -> A holds assuming by default that A is invertible.  This follows the principles of laziness.  It is however, possible to prevent this by extending the Base.inv method so as to throw an exception when applied to the specific type of A:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"Base.inv(::SomeNonInvertibleMapping) = error(\"non-invertible mapping\")","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"where SomeNonInvertibleMapping <: Mapping is the type of A.","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"Other example of simplifications:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"B = 3A\nC = 7B'","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"where mappings B and C are such that B*x -> 3*(A*x) and C*x -> 21*(A*x) for any vector x.  That is C*x is evaluated as 21*(A*x) not as 7*(3*(A*x)) thanks to simplifications occurring while the mapping C is constructed.","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"Using the -> to denote in the right-hand side the actual construction made by LazyAlgebra for the expression in the left-hand side and assuming A, B and C are linear mappings, the following simplications will occur:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"(A + C + B + 3C)' -> A' + B' + 4C'\n(A*B*3C)'         -> 3C'*B'*A'\ninv(A*B*3C)       -> 3\\inv(C)*inv(B)*inv(A)","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"However, if M is a non-linear mapping, then:","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"inv(A*B*3M) -> inv(M)*(3\\inv(B))*inv(A)","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"which can be compared to inv(A*B*3C) when all operands are linear mappings.","category":"page"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"note: Note\nDue to the associative rules applied by Julia, parentheses are needed around constructions like 3*C if it has to be interpreted as 3C in all contexes.  Otherwise, A*B*(3*C) is equivalent to A*B*3C while A*B*3*C is interpreted as ((A*B)*3)*C; that is, compose A and B, apply A*B to 3 and right multiply the result by C.","category":"page"},{"location":"introduction/#Creating-new-mappings","page":"Lazy algebra framework","title":"Creating new mappings","text":"","category":"section"},{"location":"introduction/","page":"Lazy algebra framework","title":"Lazy algebra framework","text":"LazyAlgebra provides a number of simple mappings.  Creating new primitive mapping types (not by combining existing mappings as explained above) which benefit from the LazyAlgebra framework is as simple as declaring a new mapping subtype of Mapping (or one of its abstract subtypes) and extending two methods vcreate and apply! specialized for the new mapping type.  For mode details, see here.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"LazyAlgebra is not yet an offical Julia package but it is easy to install it from Julia as explained below.  Note that LazyAlgebra requires the ArrayTools package.","category":"page"},{"location":"install/#Using-the-package-manager","page":"Installation","title":"Using the package manager","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"At the REPL of Julia, hit the ] key to switch to the package manager REPL (you should get a ... pkg> prompt) and type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add https://github.com/emmt/ArrayTools.jl\npkg> add https://github.com/emmt/StructuredArrays.jl\npkg> add https://github.com/emmt/ZippedArrays.jl\npkg> add https://github.com/emmt/LazyAlgebra.jl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"where pkg> represents the package manager prompt and https protocol has been assumed; if ssh is more suitable for you, then type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add git@github.com:emmt/ArrayTools.jl\npkg> add git@github.com:emmt/LazyAlgebra.jl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"instead.  To check whether the LazyAlgebra package works correctly, type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> test LazyAlgebra","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Later, to update to the last version (and run tests), you can type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> update LazyAlgebra\npkg> build LazyAlgebra\npkg> test LazyAlgebra","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If something goes wrong, it may be because you already have an old version of LazyAlgebra.  Uninstall LazyAlgebra as follows:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> rm LazyAlgebra\npkg> gc\npkg> add https://github.com/emmt/LazyAlgebra.jl","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"before re-installing.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To revert to Julia's REPL, hit the Backspace key at the ... pkg> prompt.","category":"page"},{"location":"install/#Installation-in-scripts","page":"Installation","title":"Installation in scripts","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To install LazyAlgebra in a Julia script, write:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"if VERSION >= v\"0.7.0-\"; using Pkg; end\nPkg.add(PackageSpec(url=\"https://github.com/emmt/LazyAlgebra.jl\", rev=\"master\"));","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"or with url=\"git@github.com:emmt/LazyAlgebra.jl\" if you want to use ssh.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This also works from the Julia REPL.","category":"page"},{"location":"sparse/#Sparse-operators","page":"Sparse operators","title":"Sparse operators","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"A sparse operator (SparseOperator) in LazyAlgebra is the generalization of a sparse matrix.  Like a GeneralMatrix, rows and columns may be multi-dimensional.  However unlike a GeneralMatrix, a sparse operator only stores its structural non-zero entries and thus requires fewer memory and is usually faster to apply.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"There are many different possibilities for storing a sparse operator, hence SparseOperator{T,M,N} is an abstract type inherited by the concrete types implementing compressed sparse storage in various formats.  Parameter T is the type of the elements while parameters M and N are the number of dimensions of the rows and of the columns respectively.  Objects of this kind are a generalization of sparse matrices in the sense that they implement linear mappings which can be applied to N-dimensional arguments to produce M-dimensional results (as explained below).  The construction of a sparse operator depends on its storage format.  Several concrete implementations are provided: Compressed Sparse Row (CSR), Compressed Sparse Column (CSC) and Compressed Sparse Coordinate (COO).","category":"page"},{"location":"sparse/#Basic-methods","page":"Sparse operators","title":"Basic methods","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"The following methods are generally applicable to any sparse operator A:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"eltype(A) yields T, the type of the elements of A;\nrow_size(A) yields an M-tuple of Int: the size of the rows of A, this is equivalent to output_size(A);\ncol_size(A) yields an Ntuple of Int: the size of the columns of A, this is equivalent to input_size(A);\nnrows(A) yields prod(row_size(A)), the equivalent number of rows of A;\nncols(A) yields prod(col_size(A)), the equivalent number of columns of A.\nndims(A) yields M + N the number of dimensions of the regular array  corresponding to the sparse operator A;\nsize(A) yields (row_size(A)..., col_size(A)...) the size of the regular  array corresponding to the sparse operator A;\nlength(A) yields prod(size(A)) the number of elements of the regular  array corresponding to the sparse operator A;\nnnz(A) yields the number of structural non-zeros in A;\nnonzeros(A) yields the vector of structural non-zeros in A.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"The structural non-zeros are the entries stored by the sparse structure, they may or not be equal to zero, un-stored entries are always considered as being equal to zero.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"As can be seen above, eltype, ndims, size and length yield the same results as if applied to the multi-dimensional array corresponding to the sparse operator.","category":"page"},{"location":"sparse/#Generalized-matrix-multplication-by-a-sparse-operator","page":"Sparse operators","title":"Generalized matrix multplication by a sparse operator","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"A sparse operator A can be directly used as any linear mapping in LazyAlgebra:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"A*x","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"yields the generalized matrix multiplication of x by A.  The size of x must be that of the columns of A, that is col_size(A).  The result is an array whose size is that of the rows of A, that is size(A*x) = row_size(A).  Applying the adjoint of A is also implemented by the usual syntax:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"A'*y","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"to produce an array of size col_size(A) provided y is of suitable size, i.e. size(y) = row_size(A).","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Sparse operators can be used as iterators, the value returned by the iterator is a 3-tuple (v,i,j) with the value, the linear row index and the linear column index of the entry.  For instance:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"for (v,i,j) in A\n    println(\"A[$i,$j] = $v\")\nend","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"This can be used to illustrate how w = A*x and z = A'*y could be computed for the sparse operator A:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"# Compute w = A*x:\n@assert !Base.has_offset_axes(x)\n@assert size(x) == col_size(A)\nT = promote_type(eltype(A),eltype(x))\nw = zeros(T, row_size(A))\n@inbounds for (v,i,j) in A\n    w[i] += v*x[j]\nend","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"and","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"# Compute z = A'*y:\n@assert !Base.has_offset_axes(y)\n@assert size(y) == row_size(A)\nT = promote_type(eltype(A),eltype(y))\nz = zeros(T, col_size(A))\n@inbounds for (v,i,j) in A\n    z[j] += conj(v)*y[i]\nend","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Actual implementations of sparse operators in LazyAlgebra are equivalent to the above examples but should be more efficient because they exploit the specific storage format of a compressed sparse operator (see CompressedSparseOperator, SparseOperatorCSR, SparseOperatorCSC and SparseOperatorCOO).","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"note: Note\nFor now, row and column indices are restricted to be linear indices and arguments to the linear mappings implemented by compressed sparse operators must be arrays with conventional indexing (1-based linear indices) and preferably implementing linear indices (not Cartesian ones).","category":"page"},{"location":"sparse/#Simple-construction-of-compressed-sparse-operators","page":"Sparse operators","title":"Simple construction of compressed sparse operators","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Compressed sparse operators only store their structural non-zero elements.  The abstract super-type of these sparse operators is CompressedSparseOperator{F,T,M,N} which is a direct sub-type of SparseOperator{T,M,N} with an additional parameter F to specify the storage format.  The parameter F is specificed as a symbol and can be:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":":COO for Compressed Sparse Coordinate storage format.  This format is not the most efficient, it is mostly used as an intermediate for building a sparse operator in one of the following format.\n:CSC for Compressed Sparse Column storage format.  This format is very efficient for applying the adjoint of the sparse operator.\n:CSR for Compressed Sparse Row storage format.  This format is very efficient for directly applying the sparse operator.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"To construct a compressed sparse operator in a given format F from the values in a 2-dimensional array A call:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{F}(A, sel = (v,i,j) -> (v != zero(v)))","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"where optional argument sel is a selector function which is called as sel(v,i,j) with v, i and j the value, the row and the column linear indices for each entries of A and which is assumed to yield true for the entries of A to be selected in the sparse structure and false for the entries of A to discard.  The default selector is such that all non-zeros of A are selected.  As an example, to select the non-zeros of the lower triangular part of A, the constructor can be called as:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{F}(A, (v,i,j) -> ((i ≥ j)&(v != zero(v))))","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Note the (slight) optimization of the expression with a biwise AND & instead of a short-circuiting logical AND && to avoid branching.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"By default the values of the structural non-zeros of the sparse operator have the same type as the elements of A, you can enforce a specific element type T with:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{F,T}(A[, sel])","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"To generalize the matrix-vector product, a sparse operator can emulate an array with more than 2 dimensions.  In that case, you must specify the number M of leading dimensions that are considered as the rows:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{F,T,M}(A[, sel])","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"The number N of trailing dimensions that are considered as the columns can also be specified (although they can be automatically guessed):","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{F,T,M,N}(A[, sel])","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"with the restriction that M ≥ 1, N ≥ 1 and M + N = ndims(A).  Note that parameter T can be Any to keep the same element type as A.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Finally, the type V of the vector used to store the coefficients of the sparse operator may also be specified:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{F,T,M,N,V}(A[, sel])","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"with the restriction that V must have standard linear indexing.  The default is to take V = Vector{T}.  As a special case, you can choose a uniform boolean vector from the StructuredArrays package to store the sparse coefficients:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{F,T,M,N,UniformVector{Bool}}(A[, sel])","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"yields a compressed sparse operator whose values are an immutable uniform vector of true values requiring no storage.  This is useful if you want to only store the sparse structure of the selected values, that is their indices in the compressed format F not their values.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"As explained in the last sections, compressed sparse operators can also be consructed by providing the values of the structural non-zeros and their respective row and column indices.  As a general rule, to construct (or convert to) a sparse operator with compressed storage format F, you can call:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{F}(args...; kwds...)\nCompressedSparseOperator{F,T}(args...; kwds...)\nCompressedSparseOperator{F,T,M}(args...; kwds...)\nCompressedSparseOperator{F,T,M,N}(args...; kwds...)\nCompressedSparseOperator{F,T,M,N,V}(args...; kwds...)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"where given parameters T, M, N and V, arguments args... and optional keywords kwds... will be passed to the concrete constructor SparseOperatorCOO, SparseOperatorCSC or SparseOperatorCSR corresponding to the format F.  For instance,","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{:CSR}(A) -> SparseOperatorCSR(A)","category":"page"},{"location":"sparse/#Accessing-the-structural-non-zeros","page":"Sparse operators","title":"Accessing the structural non-zeros","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"It is possible to use a compressed sparse operator A as an iterator:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"for (Aij,i,j) in A # simple but slow for CSR and CSC\n    ...\nend","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"to retrieve the values Aij and respective row i and column j indices for all the entries stored in A.  It is however more efficient to access them according to their storage order which depends on the compressed format.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"If A is in CSC format:\nusing LazyAlgebra.SparseMethods\nfor j in each_col(A)        # loop over column index\n    for k in each_off(A, j) # loop over structural non-zeros in this column\n        i   = get_row(A, k) # get row index of entry\n        Aij = get_val(A, k) # get value of entry\n     end\nend\nIf A is in CSR format:\nusing LazyAlgebra.SparseMethods\nfor i in each_row(A)        # loop over row index\n    for k in each_off(A, i) # loop over structural non-zeros in this row\n        j   = get_col(A, k) # get column index of entry\n        Aij = get_val(A, k) # get value of entry\n     end\nend\nIf A is in COO format:\nusing LazyAlgebra.SparseMethods\nfor k in each_off(A)\n     i   = get_row(A, k) # get row index of entry\n     j   = get_col(A, k) # get column index of entry\n     Aij = get_val(A, k) # get value of entry\nend","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"The low-level methods each_row, each_col, each_off, get_row, get_col and get_val are not automatically exported by LazyAlgebra, this is the purpose of the statement using LazyAlgebra.SparseMethods.  These methods may be extended to implement variants of compressed sparse operators.","category":"page"},{"location":"sparse/#Sparse-operators-in-COO-format","page":"Sparse operators","title":"Sparse operators in COO format","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Sparse operators in Compressed Sparse Coordinate (COO) format store the significant entries in no particular order, as a vector of values, a vector of linear row indices and a vector of linear column indices.  It is even possible to have repeated entries.  This format is very useful to build a sparse operator.  It can be converted to a more efficient format like Compressed Sparse Column or Compressed Sparse Row for fast application of the sparse linear mapping or of its adjoint.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"A sparse operator in with COO storage can be directly constructed by:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{:COO}(vals, rows, cols, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"which is the same as:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"SparseOperatorCOO(vals, rows, cols, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"or, if you want to force the element type of the result, one of the following:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{:COO,T}(vals, rows, cols, rowsiz, colsiz)\nSparseOperatorCOO{T}(vals, rows, cols, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Here, vals is the vector of values of the sparse entries, rows and cols are integer valued vectors with the linear row and column indices of the sparse entries, rowsiz and colsiz are the sizes of the row and column dimensions. The entries values and respective linear row and column indices of the k-th sparse entry are given by vals[k], rows[k] and cols[k].","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"For efficiency reasons, sparse operators are currently limited to fast arrays because they can be indexed linearly with no loss of performances.  If vals, rows and/or cols are not fast arrays, they will be automatically converted to linearly indexed arrays.","category":"page"},{"location":"sparse/#Sparse-operators-in-CSC-format","page":"Sparse operators","title":"Sparse operators in CSC format","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Sparse operators in Compressed Sparse Column (CSC) format store the significant entries in a column-wise order, as a vector of values, a vector of corresponding linear row indices and a vector of offsets indicating, for each column, the range of indices in the vectors of values and of row indices.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"A sparse operator in with CSC storage can be directly constructed by:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{:CSC}(vals, rows, offs, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"which is the same as:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"SparseOperatorCSC(vals, rows, offs, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"or, if you want to force the element type of the result, one of the following:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{:CSC,T}(vals, rows, offs, rowsiz, colsiz)\nSparseOperatorCSC{T}(vals, rows, offs, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Here, vals is the vector of values of the sparse entries, rows is an integer valued vector of the linear row indices of the sparse entries, offs is a column-wise table of offsets in these arrays, rowsiz and colsiz are the sizes of the row and column dimensions.  The entries values and respective linear row indices of the j-th column are given by vals[k] and rows[k] with k ∈ offs[j]+1:offs[j+1].  The linear column index j is in the range 1:n where n = prod(colsiz) is the equivalent number of columns.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"For efficiency reasons, sparse operators are currently limited to fast arrays because they can be indexed linearly with no loss of performances.  If vals, rows and/or offs are not fast arrays, they will be automatically converted to linearly indexed arrays.","category":"page"},{"location":"sparse/#Sparse-operators-in-CSR-format","page":"Sparse operators","title":"Sparse operators in CSR format","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Sparse operators in Compressed Sparse Row (CSR) format store the significant entries in a row-wise order, as a vector of values, a vector of corresponding linear column indices and a vector of offsets indicating, for each row, the range of indices in the vectors of values and of column indices.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"A sparse operator in with CSR storage can be directly constructed by:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{:CSR}(vals, cols, offs, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"which is the same as:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"SparseOperatorCSR(vals, cols, offs, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"or, if you want to force the element type of the result, one of the following:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"CompressedSparseOperator{:CSR,T}(vals, cols, offs, rowsiz, colsiz)\nSparseOperatorCSR{T}(vals, cols, offs, rowsiz, colsiz)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Here, vals is the vector of values of the sparse entries, cols is an integer valued vector of the linear column indices of the sparse entries, offs is a column-wise table of offsets in these arrays, rowsiz and colsiz are the sizes of the row and column dimensions.  The entries values and respective linear column indices of the i-th row are given by vals[k] and cols[k] with k ∈ offs[j]+1:offs[j+1].  The linear row index i is in the range 1:m where m = prod(rowsiz) is the equivalent number of rows.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"For efficiency reasons, sparse operators are currently limited to fast arrays because they can be indexed linearly with no loss of performances.  If vals, cols and/or offs are not fast arrays, they will be automatically converted to linearly indexed arrays.","category":"page"},{"location":"sparse/#Conversion","page":"Sparse operators","title":"Conversion","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Calling a sparse operator constructor can also be used to convert between different formats or to change the type of the stored values.  For example, to convert a sparse operator A into a Compressed Spase Row (CSR) format, the following calls are equivalent:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"SparseOperatorCSR(A)\nCompressedSparseOperator{:CSR}(A)\nconvert(SparseOperatorCSR, A)\nconvert(CompressedSparseOperator{:CSR}, A)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"If A is in Compressed Sparse Coordinate (COO) format, entries are sorted and duplicates merged.  This also occurs when converting from COO format to Compressed Sparse Column (CSC) format.  Such conversions are very useful as building a sparse operator in COO format is easier while CSC and CSR formats are more efficients.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"It is sufficient to specify the element type T to convert the storage format and the type of the stored values.  For example, any of the following will convert A to CSC format with element type T:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"SparseOperatorCSC{T}(A)\nCompressedSparseOperator{:CSC,T}(A)\nconvert(SparseOperatorCSC{T}, A)\nconvert(CompressedSparseOperator{:CSC,T}, A)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"If you just want to convert the type of the values stored by the sparse operator A to type T while keeping its storage format, any of the following will do the job:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"SparseOperator{T}(A)\nCompressedSparseOperator{Any,T}(A)\nconvert(SparseOperator{T}, A)\nconvert(CompressedSparseOperator{Any,T}, A)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"As can be seen, specifying Any for the format parameter in CompressedSparseOperator is a mean to keep the same storage format.","category":"page"},{"location":"sparse/#Other-methods","page":"Sparse operators","title":"Other methods","text":"","category":"section"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"A sparse operator S can be reshaped:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"reshape(S, rowdims, coldims)","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"where rowdims and coldims are the new list of dimensions for the rows and the columns, their product must be equal to the product of the former lists of dimensions (which means that you cannot change the number of elements of the input and output of a sparse operator).  The reshaped sparse operator and S share the arrays of non-zero coefficients and corresponding row and column indices, hence reshaping is a fast operation.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"The non-zero coefficients of a sparse operator S can be unpacked into a provided array A:","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"unpack!(A, S; flatten=false) -> A","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"Keyword flatten specifies whether to only consider the length of A instead of its dimensions.  In any cases, A must have as many elements as length(S) and standard linear indexing.  Just call Array(S) to unpack the coefficients of the sparse operator S without providing the destination array or Array{T}(S) if you want to a specific element type T.","category":"page"},{"location":"sparse/","page":"Sparse operators","title":"Sparse operators","text":"[LinearInterpolators]: https://github.com/emmt/LinearInterpolators.jl [SparseArrays]: https://docs.julialang.org/en/latest/stdlib/SparseArrays/#Sparse-Arrays-1 [sparse]: https://docs.julialang.org/en/latest/stdlib/SparseArrays/#SparseArrays.sparse [SparseMatrixCSC]: https://docs.julialang.org/en/latest/stdlib/SparseArrays/#SparseArrays.SparseMatrixCSC","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the documentation of the LazyAlgebra package for Julia. The sources are here.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"install.md\",\n    \"introduction.md\",\n    \"vectors.md\",\n    \"sparse.md\",\n    \"mappings.md\",\n    \"refs.md\"]","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"refs/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"refs/","page":"Reference","title":"Reference","text":"The following provides detailled documentation about types and methods provided by the LazyAlgebra package.  This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"refs/#Methods-for-linear-mappings","page":"Reference","title":"Methods for linear mappings","text":"","category":"section"},{"location":"refs/","page":"Reference","title":"Reference","text":"nrows\nncols\nrow_size\ncol_size","category":"page"},{"location":"refs/#LazyAlgebra.nrows","page":"Reference","title":"LazyAlgebra.nrows","text":"nrows(A)\n\nyields the equivalent number of rows of the linear operator A.  Not all operators extend this method.\n\nIn the implemented generalization of linear operators, the equivalent number of rows is the number of element of the result of applying the operator be it single- or multi-dimensional.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.ncols","page":"Reference","title":"LazyAlgebra.ncols","text":"ncols(A)\n\nyields the equivalent number of columns of the linear operator A.  Not all operators extend this method.\n\nIn the implemented generalization of linear operators, the equivalent number of columns is the number of element of an argument of the operator be it single- or multi-dimensional.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.row_size","page":"Reference","title":"LazyAlgebra.row_size","text":"row_size(A)\n\nyields the dimensions of the result of applying the linear operator A, this is equivalent to output_size(A).  Not all operators extend this method.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.col_size","page":"Reference","title":"LazyAlgebra.col_size","text":"col_size(A)\n\nyields the dimensions of the argument of the linear operator A, this is equivalent to input_size(A).  Not all operators extend this method.\n\n\n\n\n\n","category":"function"},{"location":"refs/#Sparse-operators","page":"Reference","title":"Sparse operators","text":"","category":"section"},{"location":"refs/#Types-and-compressed-storage-formats","page":"Reference","title":"Types and compressed storage formats","text":"","category":"section"},{"location":"refs/","page":"Reference","title":"Reference","text":"SparseOperator\nCompressedSparseOperator\nSparseOperatorCOO\nSparseOperatorCSC\nSparseOperatorCSR","category":"page"},{"location":"refs/#LazyAlgebra.SparseOperators.SparseOperator","page":"Reference","title":"LazyAlgebra.SparseOperators.SparseOperator","text":"SparseOperator{T,M,N} is the abstract type inherited by the sparse operator types. Parameter T is the type of the elements.  Parameters M and N are the number of dimensions of the rows and of the columns respectively. Sparse operators are a generalization of sparse matrices in the sense that they implement linear mappings which can be applied to N-dimensonal arguments to produce M-dimensional results (as explained below).  See GeneralMatrix for a similar generalization but for dense matrices.\n\nSee CompressedSparseOperator for usage of sparse operators implementing compressed storage formats.\n\n\n\n\n\n","category":"type"},{"location":"refs/#LazyAlgebra.SparseOperators.CompressedSparseOperator","page":"Reference","title":"LazyAlgebra.SparseOperators.CompressedSparseOperator","text":"CompressedSparseOperator{F,T,M,N} is an abstract sub-type of SparseOperator{T,M,N} and is inherited by the concrete types implementing sparse operators with compressed storage in format F.\n\nFormat F is specificed as a symbol and can be:\n\n:COO for Compressed Sparse Coordinate storage format.  This format is not the most efficient, it is mostly used as an intermediate for building a sparse operator in one of the following formats.\n:CSC for Compressed Sparse Column storage format.  This format is very efficient for applying the adjoint of the sparse operator.\n:CSR for Compressed Sparse Row storage format.  This format is very efficient for directly applying the sparse operator.\n\nTo construct (or convert to) a sparse operator with compressed storage format F, you can call:\n\nCompressedSparseOperator{F}(args...; kwds...)\nCompressedSparseOperator{F,T}(args...; kwds...)\nCompressedSparseOperator{F,T,M}(args...; kwds...)\nCompressedSparseOperator{F,T,M,N}(args...; kwds...)\n\nwhere given parameters T, M and N, arguments args... and optional keywords kwds... will be passed to the concrete constructor SparseOperatorCOO, SparseOperatorCSC or SparseOperatorCSR corresponding to the format F.\n\nIt is possible to use a compressed sparse operator A as an iterator:\n\nfor (Aij,i,j) in A # simple but slow for CSR and CSC\n    ...\nend\n\nto retrieve the values Aij and respective row i and column j indices for all the entries stored in A.  It is however more efficient to access them according to their storage order which depends on the compressed format.\n\nIf A is in CSC format:\nusing LazyAlgebra.SparseMethods\nfor j in each_col(A)        # loop over column index\n    for k in each_off(A, j) # loop over structural non-zeros in this column\n        i   = get_row(A, k) # get row index of entry\n        Aij = get_val(A, k) # get value of entry\n     end\nend\nIf A is in CSR format:\nusing LazyAlgebra.SparseMethods\nfor i in each_row(A)        # loop over row index\n    for k in each_off(A, i) # loop over structural non-zeros in this row\n        j   = get_col(A, k) # get column index of entry\n        Aij = get_val(A, k) # get value of entry\n     end\nend\nIf A is in COO format:\nusing LazyAlgebra.SparseMethods\nfor k in each_off(A)\n     i   = get_row(A, k) # get row index of entry\n     j   = get_col(A, k) # get column index of entry\n     Aij = get_val(A, k) # get value of entry\nend\n\nThe low-level methods each_row, each_col, each_off, get_row, get_col and get_val are not automatically exported by LazyAlgebra, this is the purpose of the statement using LazyAlgebra.SparseMethods.\n\n\n\n\n\n","category":"type"},{"location":"refs/#LazyAlgebra.SparseOperators.SparseOperatorCOO","page":"Reference","title":"LazyAlgebra.SparseOperators.SparseOperatorCOO","text":"Sparse operators in Compressed Sparse Coordinate (COO) format store the significant entries in no particular order, as a vector of values, a vector of linear row indices and a vector of linear column indices. It is even possible to have repeated entries. This format is very useful to build a sparse linear operator. It can be converted to a more efficient format like Compressed Sparse Column (CSC) or Compressed Sparse Row (CSR) for fast application of the sparse linear mapping or of its adjoint.\n\nA sparse operator in COO storage format can be constructed by providing all necessary information:\n\nSparseOperatorCOO(vals, rows, cols, rowsiz, colsiz)\n\nwhere vals is the vector of values of the sparse entries, rows and cols are integer valued vectors with the linear row and column indices of the sparse entries, rowsiz and colsiz are the sizes of the row and column dimensions. The entries values and respective linear row and column indices of the k-th sparse entry are given by vals[k], rows[k] and cols[k].  For efficiency reasons, sparse operators are currently limited to fast arrays because they can be indexed linearly with no loss of performances.  If vals, rows and/or cols are not fast arrays, they will be automatically converted to linearly indexed arrays.\n\nA sparse operator in COO storage format can be directly constructed from a 2-dimensional Julia array A:\n\nSparseOperatorCOO(A, sel = (v,i,j) -> (v != zero(v)))\n\nwhere optional argument sel is a selector function which is called as sel(v,i,j) with v, i and j the value, the row and the column linear indices for each entries of A and which is assumed to yield true for the entries of A to be selected in the sparse structure and false for the entries of A to discard.  The default selector is such that all non-zeros of A are selected.\n\nThe element type, say T, for the sparse coefficients can be imposed by rewriting the above examples as:\n\nSparseOperatorCOO{T}(args...)\n\nA sparse operator in COO storage format implementing generalized matrix-vector multiplication can also be directly constructed from a L-dimensional Julia array (with L ≥ 2) A by:\n\nSparseOperatorCOO{T,M}(A[, sel])\n\nwith M the number of leading dimensions of A corresponding to the rows of the operator, the trailing N = L - M dimensions being assumed to correspond to the columns of the operator.  These dimensions are the size of, respectively, the output and the input arrays when applying the operator.  The parameter N may be specified (although it can be automatically determined):\n\nSparseOperatorCOO{T,M,N}(A[, sel])\n\nprovided the equality M + N = ndims(A) holds.\n\nA last parameter V can be specified for the type of the vector to store the coefficients of the sparse operator:\n\nSparseOperatorCOO{T,M,N,V}(args...)\n\nprovided V implements standard linear indexing.  The default is to take V = Vector{T}.  As a special case, you can choose a uniform boolean vector from the StructuredArrays package to store the sparse coefficients:\n\nSparseOperatorCOO{T,M,N,UniformVector{Bool}}(args...)\n\nto get a compressed sparse operator in COO format whose values are an immutable uniform vector of true values requiring no storage.  This is useful to only store the sparse structure of the operator, that is the indices in COO format of the sparse coefficients not their values.\n\nThe SparseOperatorCOO constructor can also be used to convert a sparse operator in another storage format into the COO format.  In that case, parameter T may also be specified to convert the type of the sparse coefficients.\n\n\n\n\n\n","category":"type"},{"location":"refs/#LazyAlgebra.SparseOperators.SparseOperatorCSC","page":"Reference","title":"LazyAlgebra.SparseOperators.SparseOperatorCSC","text":"Sparse operators in Compressed Sparse Column (CSC) format store the significant entries in a column-wise order, as a vector of values, a vector of corresponding linear row indices and a vector of offsets indicating, for each column, the range of indices in the vectors of values and of row indices.  This storage format is very suitable for fast application of the operator, notably its adjoint.\n\nA sparse operator in CSC storage format can be constructed by providing all necessary information:\n\nSparseOperatorCSC(vals, rows, offs, rowsiz, colsiz)\n\nwhere vals is the vector of values of the sparse entries, rows is an integer valued vector of the linear row indices of the sparse entries, offs is a column-wise table of offsets in these arrays, rowsiz and colsiz are the sizes of the row and column dimensions.  The entries values and respective linear row indices of the j-th column are given by vals[k] and rows[k] with k ∈ offs[j]+1:offs[j+1].  The linear column index j is in the range 1:n where n = prod(colsiz) is the equivalent number of columns.  For efficiency reasons, sparse operators are currently limited to fast arrays because they can be indexed linearly with no loss of performances.  If vals, rows and/or offs are not fast arrays, they will be automatically converted to linearly indexed arrays.\n\nA sparse operator in CSC storage format can be directly constructed from a 2-dimensional Julia array A:\n\nSparseOperatorCSC(A, sel = (v,i,j) -> (v != zero(v)))\n\nwhere optional argument sel is a selector function which is called as sel(v,i,j) with v, i and j the value, the row and the column linear indices for each entries of A and which is assumed to yield true for the entries of A to be selected in the sparse structure and false for the entries of A to discard.  The default selector is such that all non-zeros of A are selected.\n\nThe element type, say T, for the sparse coefficients can be imposed by rewriting the above examples as:\n\nSparseOperatorCSC{T}(args...)\n\nA sparse operator in CSC storage format implementing generalized matrix-vector multiplication can also be directly constructed from a L-dimensional Julia array (with L ≥ 2) A by:\n\nSparseOperatorCSC{T,M}(A[, sel])\n\nwith M the number of leading dimensions of A corresponding to the rows of the operator, the trailing N = L - M dimensions being assumed to correspond to the columns of the operator.  These dimensions are the size of, respectively, the output and the input arrays when applying the operator.  The parameter N may be specified (although it can be automatically determined):\n\nSparseOperatorCSC{T,M,N}(A[, sel])\n\nprovided the equality M + N = ndims(A) holds.\n\nA last parameter V can be specified for the type of the vector to store the coefficients of the sparse operator:\n\nSparseOperatorCSC{T,M,N,V}(args...)\n\nprovided V implements standard linear indexing.  The default is to take V = Vector{T}.  As a special case, you can choose a uniform boolean vector from the StructuredArrays package to store the sparse coefficients:\n\nSparseOperatorCSC{T,M,N,UniformVector{Bool}}(args...)\n\nto get a compressed sparse operator in CSC format whose values are an immutable uniform vector of true values requiring no storage.  This is useful to only store the sparse structure of the operator, that is the indices in CSC format of the sparse coefficients not their values.\n\nThe SparseOperatorCSC constructor can also be used to convert a sparse operator in another storage format into the CSC format.  In that case, parameter T may also be specified to convert the type of the sparse coefficients.\n\n\n\n\n\n","category":"type"},{"location":"refs/#LazyAlgebra.SparseOperators.SparseOperatorCSR","page":"Reference","title":"LazyAlgebra.SparseOperators.SparseOperatorCSR","text":"Sparse operators in Compressed Sparse Row (CSR) format store the significant entries in a row-wise order, as a vector of values, a vector of corresponding linear column indices and a vector of offsets indicating, for each row, the range of indices in the vectors of values and of column indices.  This storage format is very suitable for fast application of the operator.\n\nA sparse operator in CSR storage format can be constructed by providing all necessary information:\n\nSparseOperatorCSR(vals, cols, offs, rowsiz, colsiz)\n\nwhere vals is the vector of values of the sparse entries, cols is an integer valued vector of the linear column indices of the sparse entries, offs is a column-wise table of offsets in these arrays, rowsiz and colsiz are the sizes of the row and column dimensions.  The entries values and respective linear column indices of the i-th row are given by vals[k] and cols[k] with k ∈ offs[i]+1:offs[i+1].  The linear row index i is in the range 1:m where m = prod(rowsiz) is the equivalent number of rows.  For efficiency reasons, sparse operators are currently limited to fast arrays because they can be indexed linearly with no loss of performances.  If vals, cols and/or offs are not fast arrays, they will be automatically converted to linearly indexed arrays.\n\nA sparse operator in CSR storage format can be directly constructed from a 2-dimensional Julia array A:\n\nSparseOperatorCSR(A, sel = (v,i,j) -> (v != zero(v)))\n\nwhere optional argument sel is a selector function which is called as sel(v,i,j) with v, i and j the value, the row and the column linear indices for each entries of A and which is assumed to yield true for the entries of A to be selected in the sparse structure and false for the entries of A to discard.  The default selector is such that all non-zeros of A are selected.\n\nThe element type, say T, for the sparse coefficients can be imposed by rewriting the above examples as:\n\nSparseOperatorCSR{T}(args...)\n\nA sparse operator in CSR storage format implementing generalized matrix-vector multiplication can also be directly constructed from a L-dimensional Julia array (with L ≥ 2) A by:\n\nSparseOperatorCSR{T,M}(A[, sel])\n\nwith M the number of leading dimensions of A corresponding to the rows of the operator, the trailing N = L - M dimensions being assumed to correspond to the columns of the operator.  These dimensions are the size of, respectively, the output and the input arrays when applying the operator.  The parameter N may be specified (although it can be automatically determined):\n\nSparseOperatorCSR{T,M,N}(A[, sel])\n\nprovided the equality M + N = ndims(A) holds.\n\nA last parameter V can be specified for the type of the vector to store the coefficients of the sparse operator:\n\nSparseOperatorCSR{T,M,N,V}(args...)\n\nprovided V implements standard linear indexing.  The default is to take V = Vector{T}.  As a special case, you can choose a uniform boolean vector from the StructuredArrays package to store the sparse coefficients:\n\nSparseOperatorCSR{T,M,N,UniformVector{Bool}}(args...)\n\nto get a compressed sparse operator in CSR format whose values are an immutable uniform vector of true values requiring no storage.  This is useful to only store the sparse structure of the operator, that is the indices in CSR format of the sparse coefficients not their values.\n\nThe SparseOperatorCSR constructor can also be used to convert a sparse operator in another storage format into the CSR format.  In that case, parameter T may also be specified to convert the type of the sparse coefficients.\n\n\n\n\n\n","category":"type"},{"location":"refs/#Methods","page":"Reference","title":"Methods","text":"","category":"section"},{"location":"refs/","page":"Reference","title":"Reference","text":"LazyAlgebra.SparseOperators.unpack!","category":"page"},{"location":"refs/#LazyAlgebra.SparseOperators.unpack!","page":"Reference","title":"LazyAlgebra.SparseOperators.unpack!","text":"unpack!(A, S; flatten=false) -> A\n\nunpacks the non-zero coefficients of the sparse operator S into the array A and returns A.  Keyword flatten specifies whether to only consider the length of A instead of its dimensions.  In any cases, A must have as many elements as length(S) and standard linear indexing.\n\nJust call Array(S) to unpack the coefficients of a sparse operator S without providing the destination array.\n\n\n\n\n\n","category":"function"},{"location":"refs/#Low-level-interface","page":"Reference","title":"Low-level interface","text":"","category":"section"},{"location":"refs/","page":"Reference","title":"Reference","text":"These methods are provided by using LazyAlgebra.SparseMethods.","category":"page"},{"location":"refs/","page":"Reference","title":"Reference","text":"LazyAlgebra.SparseMethods.each_row\nLazyAlgebra.SparseMethods.each_col\nLazyAlgebra.SparseMethods.each_off\nLazyAlgebra.SparseMethods.get_row\nLazyAlgebra.SparseMethods.get_rows\nLazyAlgebra.SparseMethods.get_col\nLazyAlgebra.SparseMethods.get_cols\nLazyAlgebra.SparseMethods.get_val\nLazyAlgebra.SparseMethods.get_vals\nLazyAlgebra.SparseMethods.set_val!\nLazyAlgebra.SparseMethods.get_offs\nLazyAlgebra.SparseMethods.copy_rows\nLazyAlgebra.SparseMethods.copy_cols\nLazyAlgebra.SparseMethods.copy_vals","category":"page"},{"location":"refs/#LazyAlgebra.SparseOperators.each_row","page":"Reference","title":"LazyAlgebra.SparseOperators.each_row","text":"each_row(A)\n\nyields an iterator over the linear row indices of the sparse operator A stored in a Compressed Sparse Row (CSR) format, this includes the adjoint of a sparse operator in Compressed Sparse Column (CSC) format.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.each_col","page":"Reference","title":"LazyAlgebra.SparseOperators.each_col","text":"each_col(A)\n\nyields an iterator over the linear column indices of the sparse operator A stored in a Compressed Sparse Column (CSC) format, this includes the adjoint of a sparse operator in Compressed Sparse Row (CSR) format.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.each_off","page":"Reference","title":"LazyAlgebra.SparseOperators.each_off","text":"For a sparse operator A stored in a Compressed Sparse Coordinate (COO) format, the call:\n\neach_off(A)\n\nyields an iterator over the indices in the arrays of values and of linear row and column indices for the k-th entry of A.\n\n\n\nFor a sparse operator A stored in a Compressed Sparse Column (CSC) format, the call:\n\neach_off(A, j)\n\nyields an iterator over the indices in the arrays of values and linear row indices for the j-th column of A.\n\n\n\nFor a sparse operator A stored in a Compressed Sparse Row (CSR) format, the call:\n\neach_off(A, i)\n\nyields an iterator over the indices in the arrays of values and linear column indices for the i-th row of A.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.get_row","page":"Reference","title":"LazyAlgebra.SparseOperators.get_row","text":"get_row(A, k) -> i\n\nyields the linear row index of the k-th entry of the sparse operator A stored in a Compressed Sparse Column (CSC) or Coordinate (COO) formats (this includes adjoint of sparse operators in CSR format).\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.get_rows","page":"Reference","title":"LazyAlgebra.SparseOperators.get_rows","text":"get_rows(A)\n\nyields the row indices of the entries of the sparse operator A.  The returned array may be shared with A, call copy_rows(A) instead if you want to modify the contents of the returned array with no side effects on A.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.get_col","page":"Reference","title":"LazyAlgebra.SparseOperators.get_col","text":"get_col(A, k) -> j\n\nyields the linear column index of the k-th entry of the sparse operator A stored in a Compressed Sparse Row (CSR) or Coordinate (COO) formats (this includes adjoint of sparse operators in CSC format).\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.get_cols","page":"Reference","title":"LazyAlgebra.SparseOperators.get_cols","text":"get_cols(A)\n\nyields the column indices of the entries of the sparse operator A.  The returned array may be shared with A, call copy_cols(A) instead if you want to modify the contents of the returned array with no side effects on A.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.get_val","page":"Reference","title":"LazyAlgebra.SparseOperators.get_val","text":"get_val(A, k) -> v\n\nyields the value of the k-th entry of the sparse operator A stored in a Compressed Sparse Row (CSR), Compressed Sparse Column (CSC) or Coordinate (COO) format.\n\nArgument may also be the adjoint of a sparse operator:\n\nget_val(A', k) -> conj(get_val(A, k))\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.get_vals","page":"Reference","title":"LazyAlgebra.SparseOperators.get_vals","text":"get_vals(A)\n\nyields the array storing the values of the sparse operator A.  The returned array is shared with A, call copy_vals(A) instead if you want to modify the contents of the returned array with no side effects on A.\n\nAs a convenience, argument may also be the adjoint of a sparse operator:\n\nget_vals(A') -> get_vals(A)\n\nwhich yields the unmodified values of A, hence the caller has to take the conjugate of these values.  The method get_val(A',k) however takes care of conjugating the values.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.set_val!","page":"Reference","title":"LazyAlgebra.SparseOperators.set_val!","text":"set_val!(A, k, v) -> v\n\nassigns v to the value of the k-th entry of the sparse operator A stored in a Compressed Sparse Row (CSR), Compressed Sparse Column (CSC) or Coordinate (COO) format.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.get_offs","page":"Reference","title":"LazyAlgebra.SparseOperators.get_offs","text":"get_offs(A)\n\nyields the table of offsets of the sparse operator A.  Not all operators extend this method.\n\nwarning: Warning\nThe interpretation of offsets depend on the type of A.  For instance, assuming offs = get_offs(A), then the index range of the j-th column of a SparseMatrixCSC is offs[j]:(offs[j+1]-1) while the index range is (offs[j]+1):offs[j+1] for a SparseOperatorCSC.  For this reason, it is recommended to call each_off instead or to call get_offs with 2 arguments as shown below.\n\nFor a transparent usage of the offsets, the method should be called with 2 arguments:\n\nget_offs(A, i) -> k1, k2\n\nwhich yields the offsets of the first and last elements in the arrays of values and linear column indices for the i-th row of the sparse operator A stored in a Compressed Sparse Row (CSR) format.  If k2 < k1, it means that the i-th row is empty.  Calling each_off(A,i) directly yields k1:k2.\n\nget_offs(A, j) -> k1, k2\n\nyields the offsets of the first and last elements in the arrays of values and linear row indices for the j-th column of the sparse operator A stored in a Compressed Sparse Column (CSC) format.  If k2 < k1, it means that the j-th column is empty.  Calling each_off(A,j) directly yields k1:k2.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.copy_rows","page":"Reference","title":"LazyAlgebra.SparseOperators.copy_rows","text":"copy_rows(A) -> rows\n\nyields a copy of the linear row indices of entries in sparse operator A.  The result is a vector that is not shared by A, the caller may thus modify its contents with no side effects on A.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.copy_cols","page":"Reference","title":"LazyAlgebra.SparseOperators.copy_cols","text":"copy_cols(A) -> cols\n\nyields a copy of the linear column indices of entries in sparse operator A. The result is a vector that is not shared by A, the caller may thus modify its contents with no side effects on A.\n\n\n\n\n\n","category":"function"},{"location":"refs/#LazyAlgebra.SparseOperators.copy_vals","page":"Reference","title":"LazyAlgebra.SparseOperators.copy_vals","text":"copy_vals([T = eltype(A),] A) -> vals\n\nyields a copy of the values of the entries in sparse operator A converted to type T.  The result is a vector that is not shared by A, the caller may thus modify its contents with no side effects on A.\n\n\n\n\n\n","category":"function"}]
}
