<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simplification and optimization of combinations of mappings · LazyAlgebra for Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LazyAlgebra for Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../introduction/">Lazy algebra framework</a></li><li><a class="tocitem" href="../vectors/">Methods for vectors</a></li><li><a class="tocitem" href="../sparse/">Sparse operators</a></li><li><a class="tocitem" href="../mappings/">Methods for mappings</a></li><li class="is-active"><a class="tocitem" href>Simplification and optimization of combinations of mappings</a><ul class="internal"><li><a class="tocitem" href="#Rationale-for-simplification-rules"><span>Rationale for simplification rules</span></a></li><li><a class="tocitem" href="#Implemented-simplification-rules:"><span>Implemented simplification rules:</span></a></li><li><a class="tocitem" href="#Coding-recommendations"><span>Coding recommendations</span></a></li></ul></li><li><a class="tocitem" href="../refs/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Simplification and optimization of combinations of mappings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Simplification and optimization of combinations of mappings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LazyAlgebra.jl/blob/master/docs/src/simplifications.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Simplification-and-optimization-of-combinations-of-mappings"><a class="docs-heading-anchor" href="#Simplification-and-optimization-of-combinations-of-mappings">Simplification and optimization of combinations of mappings</a><a id="Simplification-and-optimization-of-combinations-of-mappings-1"></a><a class="docs-heading-anchor-permalink" href="#Simplification-and-optimization-of-combinations-of-mappings" title="Permalink"></a></h1><p>LazyAlgebra provides mappings and structures to store arbitrarily complex combinations of mappings.  When constructing such combinations, a number of simplifications are automatically performed.  These simplifications follow a number of rules which are explained below.</p><h2 id="Rationale-for-simplification-rules"><a class="docs-heading-anchor" href="#Rationale-for-simplification-rules">Rationale for simplification rules</a><a id="Rationale-for-simplification-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rationale-for-simplification-rules" title="Permalink"></a></h2><p>A distinction must be made between:</p><ul><li><em>basic</em> mappings which are the simplest mappings and are the building blocks of more complex constructions,</li><li><em>scaled</em> or <em>decorated</em> mappings (see <a href="@ref"><code>LazyAlgebra.DecoratedMapping</code></a>) which are simple structures wrapped around a mapping and which are almost costless to build,</li><li><em>combinations</em> of mappings which are sums or compositions of mappings.</li></ul><p>As general guidelines, simplification that are automatically performed at construction time should:</p><ul><li>require as few computations as possible,</li><li>avoid creating new mappings with mutable contents,</li><li>be type stable if possible,</li><li>preserve basic mappings embedded in more complex constructions to make it more likely to realize that two mappings be identical by their types.</li></ul><p>Imposing <em>type stability</em> is not a strict requirement as it would prevent a lot of worthwile simplifications like:</p><ul><li><p><code>λ*A</code> yields <code>A</code> if <code>λ = 1</code>, a scaled mapping otherwise,</p></li><li><p><code>A + B</code> yields <code>2*A</code> if <code>B ≡ A</code>, a sum of mappings otherwise;</p></li></ul><p>There are some cases where the rules to follow are not obvious:</p><ul><li><p>Multiplying a sum of mappings, say <code>λ*(A + B + C)</code>, can be constructed as:</p><ol><li>a sum of scaled mappings, <code>λ*A + λ*B + λ*C</code>;</li><li>a scaled sum.</li></ol></li><li><p>Taking the adjoint of a sum of mappings, say <code>(A + B + C)&#39;</code>, can be:</p><ol><li>simplified into a sum of adjoints, <code>A&#39; + B&#39; + C&#39;</code>;</li><li>constructed as the adjoint of the sum.</li></ol></li><li><p>Taking the adjoint of a composition of mappings, say <code>(A*B*C)&#39;</code>, can be:</p><ol><li>simplified into a composition of adjoints, <code>C&#39;*B&#39;*A&#39;</code>;</li><li>constructed as the adjoint of the composition.</li></ol></li><li><p>Taking the inverse of a composition of mappings, say <code>inv(A*B*C)&#39;</code>, can be:</p><ol><li>simplified into a composition of inverses, <code>inv(C)*inv(B)*inv(A)</code>;</li><li>constructed as the inverse of the composition.</li></ol></li></ul><p>For all these cases, the second solution requires that (i) the <code>apply</code> method be specialized to be applicable to the resulting construction and, for consistency, that (ii) the other possible expressions be automatically recognized and constructed in the same way (for instance `<code>C&#39;*B&#39;*A&#39;</code> should be automatically simplified as <code>(A*B*C)&#39;</code>.</p><p>In the case of the scaling of a sum, it is more efficient to use the second form because is factorize the multiplication at the end of calculus.</p><p>On the one hand, the first solution is more simple to implement.  On the other hand, with the second solution, it is easier to write simplification rules that apply automatically.</p><p>The curent rules in LazyAlgebra (see the next section) implement the second solution for the multiplication of a sum by a scalar and the first solution in all other case.  This is expected to change in the future.</p><h2 id="Implemented-simplification-rules:"><a class="docs-heading-anchor" href="#Implemented-simplification-rules:">Implemented simplification rules:</a><a id="Implemented-simplification-rules:-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-simplification-rules:" title="Permalink"></a></h2><ul><li><p>Multipliers are factorized to the left as possible.</p></li><li><p>Adjoint of a sum (or a composition) of terms is rewritten as the sum (respectively composition) of the adjoint of the terms.</p></li><li><p>Adjoint of a scaled mapping is rewritten as a scaled adjoint of the mapping.  Similarly, inverse of a scaled mapping is rewritten as a scaled inverse of the mapping, if the mapping is linear, or as the inverse of the mapping times a scaled identity otherwise.</p></li><li><p>Adjoint of the inverse is rewritten as inverse of the adjoint.</p></li><li><p>Inner constructors are fully qualified but check arguments.  Un-qualified outer constructors just call the inner constructors with the suitable parameters.</p></li><li><p>To simplify a sum, the terms corresponding to identical mappings (possibly scaled) are first grouped to produce a single mapping (possibly scaled) per group, the resulting terms are sorted (so that all equivalent expressions yield the same result) and the &quot;zeros&quot; eliminated (if all terms are &quot;zero&quot;, the sum simplifies to the first one).  For now, the sorting is not absolutely perfect as it is based on <code>objectid()</code> hashing method.  The odds of having the same identifier for two different things are however extremely low.</p></li><li><p>To simplify a composition, a fusion algorithm is applied and &quot;ones&quot; are eliminated.  It is assumed that composition is non-commutative so the ordering of terms is left unchanged.  Thanks to this, simplification rules for simple compositions (made of two non-composition mappings) can be automatically performed by proper dispatching rules.  Calling the fusion algorithm is only needed for more complex compositions.</p></li></ul><p>The simplication algorithm is not perfect (LazyAlgebra is not intended to be for symbolic computations) but do a reasonnable job.  In particular complex mappings built using the same sequences should be simplified in the same way and thus be correctly identified as being identical.</p><p>Since applying a construction of mappings will result in applying its components, it can</p><pre><code class="language-julia hljs">+(A::Adjoint, B::Adjoint) = (A + B)&#39;
*(A::Adjoint, B::Adjoint) = (B*A)&#39;
*(A::Inverse, B::Inverse) = inv(B*A)
*(A::Inverse{T}, B::T) where {T&lt;:Mapping} =
    (identical(unveil(A), B) ? Id : Composition(A,B))
*(A::T, B::Inverse{T}) where {T&lt;:Mapping} =
    (identical(A, unveil(B)) ? Id : Composition(A,B))
\(A::Mapping, B::Mapping) = inv(A)*B
/(A::Mapping, B::Mapping) = A*inv(B)
adjoint(A::Adjoint) = unveil(A)
adjoint(A::AdjointInverse) = inv(A)
adjoint(A::Inverse) = AdjointInverse(A)
inv(A::Inverse) = unveil(A)
inv(A::Adjoint) = AdjointInverse(A)
inv(A::AdjointInverse) = A&#39;</code></pre><h2 id="Coding-recommendations"><a class="docs-heading-anchor" href="#Coding-recommendations">Coding recommendations</a><a id="Coding-recommendations-1"></a><a class="docs-heading-anchor-permalink" href="#Coding-recommendations" title="Permalink"></a></h2><p>To make the code easier to maintain and avoid incosistencies, there are a few recommendations to follow.  This is especially true for coding the simplification rules that are automatically performed.</p><ul><li><p>Simplification rules are initiated by specializing for mapping arguments the operators (addition, multiplication, adjoint, etc.) used in Julia expressions. Hence simplifications are automatically performed when such expressions appears in the code.</p></li><li><p>More complex rules may require calling auxiliary helper functions like <code>simplify</code>.  But the entry point for a simplification is always a simple expression so that the end user shall not have to call <code>simplify</code> directly.</p></li><li><p>To avoid building non-simplified constructions, the <code>Adjoint</code>, <code>Inverse</code>, <code>AdjointInverse</code>, <code>Scaled</code>, <code>Sum</code>, <code>Composition</code>, and <code>Gram</code> constructors should not be directly called by a end user who should use expressions like <code>A&#39;</code> to construct the adjoint, <code>inv(A)</code> for the inverse, etc.  To discourage calling constructors for combining mappings, these constructors are not exported by LazyAlgebra.</p></li><li><p>Trust the optimizer and resist to the tendency of writing very specialized rules to deal with complex cases in favor of writing more simpler and more general rules that, applied together, yield the correct answer.</p><p>For instance, the following rules would be sufficient to implement the right-multiplication and the right-division of a mapping by a scalar:</p><pre><code class="language-julia hljs">*(A::Mapping, α::Number) = (is_linear(A) ? α*A : A*(α*Id))
/(A::Mapping, α::Number) = A*inv(α)</code></pre><p>Only the right-multiplication is in charge of deciding whether the operation is commutative and these two methods returns their result as an expression to delegate the construction of the result to the methods implementing the left-multiplication of a mapping by a scalar, the composition of two mappings, etc.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mappings/">« Methods for mappings</a><a class="docs-footer-nextpage" href="../refs/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 8 November 2022 13:13">Tuesday 8 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
