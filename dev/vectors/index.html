<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods for vectors · LazyAlgebra for Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LazyAlgebra for Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../install/">Installation</a></li><li><a class="toctext" href="../introduction/">Lazy algebra framework</a></li><li class="current"><a class="toctext" href>Methods for vectors</a><ul class="internal"><li><a class="toctext" href="#Vectorized-methods-1">Vectorized methods</a></li><li><a class="toctext" href="#Implementing-a-new-vector-type-1">Implementing a new vector type</a></li></ul></li><li><a class="toctext" href="../sparse/">Sparse operators</a></li><li><a class="toctext" href="../mappings/">Methods for mappings</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Methods for vectors</a></li></ul><a class="edit-page" href="https://github.com/emmt/LazyAlgebra.jl/blob/master/docs/src/vectors.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Methods for vectors</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Methods-for-vectors-1" href="#Methods-for-vectors-1">Methods for vectors</a></h1><p>A <em>vector</em> is that which has the algebra of a vector space (Peano 1888, van der Waerden 1931).  See talk by Jiahao Chen: <a href="https://www.youtube.com/watch?v=C2RO34b_oPM"><em>Taking Vector Transposes Seriously</em></a> at JuliaCon 2017.</p><h2><a class="nav-anchor" id="Vectorized-methods-1" href="#Vectorized-methods-1">Vectorized methods</a></h2><p>Most necessary operations on the variables of interest are linear operations. Hence variables (whatever their specific type and size) are just called <em>vectors</em> in <code>LazyAlgebra</code>.  Numerical methods based on <code>LazyAlgebra</code> manipulate the variables via a small number of vectorized methods:</p><ul><li><p><code>vdot([T,][w,]x,y)</code> yields the inner product of <code>x</code> and <code>y</code>; that is, the sum of <code>conj(x[i])*y[i]</code> or, if <code>w</code> is specified, the sum of <code>w[i]*conj(x[i])*y[i]</code>, for all indices <code>i</code>.  Optional argument <code>T</code> is the type of the result; for real valued <em>vectors</em>, <code>T</code> is a floating-point type; for complex valued <em>vectors</em>, <code>T</code> can be a complex type (with floating-point parts) or a floating-point type to compute only the real part of the inner product.  <code>vdot([T,]sel,x,y)</code> yields the sum of <code>x[i]*y[i]</code> for all <code>i ∈ sel</code> where <code>sel</code> is a selection of indices.</p></li><li><p><code>vnorm1([T,]x)</code> yields the L-1 norm of <code>x</code>, that is the sum of the absolute values of the components of <code>x</code>.  Optional argument <code>T</code> is the floating-point type of the result.</p></li><li><p><code>vnorm2([T,]x)</code> yields the Euclidean (or L-2) norm of <code>x</code>, that is the square root of sum of the squared values of the components of <code>x</code>.  Optional argument <code>T</code> is the floating-point type of the result.</p></li><li><p><code>vnorminf([T,]x)</code> L-∞ norm of <code>x</code>, that is the maximal absolute values of the components of <code>x</code>.  Optional argument <code>T</code> is the floating-point type of the result</p></li><li><p><code>vcreate(x)</code> yields a new variable instance similar to <code>x</code>.  If <code>x</code> is an array, the element type of the result is a floating-point type.</p></li><li><p><code>vcopy!(dst,src)</code> copies the contents of <code>src</code> into <code>dst</code> and returns <code>dst</code>.</p></li><li><p><code>vcopy(x)</code> yields a fresh copy of the <em>vector</em> <code>x</code>.</p></li><li><p><code>vswap!(x,y)</code> exchanges the contents of <code>x</code> and <code>y</code> (which must have the same type and size if they are arrays).</p></li><li><p><code>vfill!(x,α)</code> sets all elements of <code>x</code> with the scalar value <code>α</code> and return <code>x</code>.</p></li><li><p><code>vzero!(x)</code>fills <code>x</code> with zeros and returns it.</p></li><li><p><code>vscale!(dst,α,src)</code> overwrites <code>dst</code> with <code>α*src</code> and returns <code>dst</code>.  The convention is that, if <code>α = 0</code>, then <code>dst</code> is filled with zeros whatever the contents of <code>src</code>.</p></li><li><p><code>vscale!(x,α)</code> and <code>vscale!(α,x)</code> overwrite <code>x</code> with <code>α*x</code> and returns <code>x</code>. The convention is that, if <code>α = 0</code>, then <code>x</code> is filled with zeros whatever its prior contents.</p></li><li><p><code>vscale(α,x)</code> and <code>vscale(x,α)</code> yield a new <em>vector</em> whose elements are those of <code>x</code> multiplied by the scalar <code>α</code>.</p></li><li><p><code>vproduct!(dst,[sel,]x,y)</code> overwrites <code>dst</code> with the elementwise multiplication of <code>x</code> by <code>y</code>.  Optional argument <code>sel</code> is a selection of indices to consider.</p></li><li><p><code>vproduct(x,y)</code> yields the elementwise multiplication of <code>x</code> by <code>y</code>.</p></li><li><p><code>vupdate!(y,[sel,]α,x)</code> overwrites <code>y</code> with <code>α*x + y</code> and returns <code>y</code>. Optional argument <code>sel</code> is a selection of indices to which apply the operation (if an index is repeated, the operation will be performed several times at this location).</p></li><li><p><code>vcombine(α,x,β,y)</code> yields the linear combination <code>α*x</code> or <code>α*x + β*y</code>.</p></li><li><p><code>vcombine!(dst,α,x,β,y)</code> overwrites <code>dst</code> with the linear combination <code>dst = α*x</code> or <code>dst = α*x + β*y</code> and returns <code>dst</code>.</p></li></ul><p>Note that the names of these methods all start with a <code>v</code> (for <strong>v</strong>ector) as the conventions used by these methods may be particular.  For instance, compared to <code>copy!</code> and when applied to arrays, <code>vcopy!</code> imposes that the two arguments have exactly the same dimensions.  Another example is the <code>vdot</code> method which has a slightly different semantics than Julia <code>dot</code> method.</p><p><code>LazyAlgebra</code> already provides implementations of these methods for Julia arrays with floating-point type elements.  This implementation assumes that an array is a valid <em>vector</em> providing it has suitable type and dimensions.</p><h2><a class="nav-anchor" id="Implementing-a-new-vector-type-1" href="#Implementing-a-new-vector-type-1">Implementing a new vector type</a></h2><p>To have a numerical method based on <code>LazyAlgebra</code> be applicable to a new given type of variables, it is sufficient to implement a subset of these basic methods specialized for this kind of variables.</p><p>The various operations that should be implemented for a <em>vector</em> are:</p><ul><li>compute the inner product of two vectors of the same kind (<code>vdot(x,y)</code> method);</li><li>create a vector of a given kind (<code>vcreate(x)</code> method);</li><li>copy a vector (<code>vcopy!(dst,src)</code>);</li><li>fill a vector with a given value (<code>vfill!(x,α)</code> method);</li><li>exchange the contents of two vectors (<code>vswap!(x,y)</code> method);</li><li>linearly combine several vectors (<code>vcombine!(dst,α,x,β,y)</code> method).</li></ul><p>Derived methods are:</p><ul><li>compute the Euclidean norm of a vector (<code>vnorm2</code> method, based on <code>vdot</code> by default);</li><li>multiply a vector by a scalar: <code>vscale!(dst,α,src)</code> and/or <code>vscale!(x,α)</code> methods (based on <code>vcombine!</code> by default);</li><li>update a vector by a scaled step: <code>vupdate!(y,α,x)</code> method (based on <code>vcombine!</code> by default) and, for some constrained optimization methods, <code>vupdate!(y,sel,α,x)</code> method;</li><li>erase a vector: <code>vzero!(x)</code> method (based on <code>vfill!</code> by default);</li><li><code>vscale</code> and <code>vcopy</code> methods are implemented with <code>vcreate</code> and respectively<code>vscale!</code> and <code>vcopy!</code>.</li></ul><p>Other methods which may be required by some packages:</p><ul><li>compute the L-1 norm of a vector: <code>vnorm1(x)</code> method;</li><li>compute the L-∞ norm of a vector: <code>vnorminf(x)</code> method;</li></ul><p>Methods that must be implemented (<code>V</code> represent the vector type):</p><pre><code class="language-julia">vdot(::Type{T}, x::Tx, y::Ty) :: T where {T&lt;:AbstractFloat,Tx,Ty}</code></pre><pre><code class="language-julia">vscale!(dst::V, alpha::Real, src::V) -&gt; dst</code></pre><p>methods that may be implemented:</p><pre><code class="language-julia">vscale!(alpha::Real, x::V) -&gt; x</code></pre><p>For mappings and linear operators (see <a href="../mappings/">Implementation of new mappings</a> for details), implement:</p><pre><code class="language-julia">apply!(α::Scalar, P::Type{&lt;:Operations}, A::Ta, x::Tx, β::Scalar, y::Ty) -&gt; y</code></pre><p>and</p><pre><code class="language-julia">vcreate(P::Type{P}, A::Ta, x::Tx) -&gt; y</code></pre><p>for <code>Ta&lt;:Mapping</code> and the supported operations <code>P&lt;:Operations</code>.</p><footer><hr/><a class="previous" href="../introduction/"><span class="direction">Previous</span><span class="title">Lazy algebra framework</span></a><a class="next" href="../sparse/"><span class="direction">Next</span><span class="title">Sparse operators</span></a></footer></article></body></html>
