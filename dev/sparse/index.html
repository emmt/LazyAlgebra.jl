<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse operators · LazyAlgebra for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LazyAlgebra for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../introduction/">Lazy algebra framework</a></li><li><a class="tocitem" href="../vectors/">Methods for vectors</a></li><li class="is-active"><a class="tocitem" href>Sparse operators</a><ul class="internal"><li><a class="tocitem" href="#Basic-methods"><span>Basic methods</span></a></li><li><a class="tocitem" href="#Generalized-matrix-multplication-by-a-sparse-operator"><span>Generalized matrix multplication by a sparse operator</span></a></li><li><a class="tocitem" href="#Simple-construction-of-compressed-sparse-operators"><span>Simple construction of compressed sparse operators</span></a></li><li><a class="tocitem" href="#Accessing-the-structural-non-zeros"><span>Accessing the structural non-zeros</span></a></li><li><a class="tocitem" href="#Sparse-operators-in-COO-format"><span>Sparse operators in COO format</span></a></li><li><a class="tocitem" href="#Sparse-operators-in-CSC-format"><span>Sparse operators in CSC format</span></a></li><li><a class="tocitem" href="#Sparse-operators-in-CSR-format"><span>Sparse operators in CSR format</span></a></li><li><a class="tocitem" href="#Conversion"><span>Conversion</span></a></li><li><a class="tocitem" href="#Other-methods"><span>Other methods</span></a></li></ul></li><li><a class="tocitem" href="../mappings/">Methods for mappings</a></li><li><a class="tocitem" href="../simplifications/">Simplification and optimization of combinations of mappings</a></li><li><a class="tocitem" href="../refs/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sparse operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparse operators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LazyAlgebra.jl/blob/master/docs/src/sparse.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-operators"><a class="docs-heading-anchor" href="#Sparse-operators">Sparse operators</a><a id="Sparse-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-operators" title="Permalink"></a></h1><p>A sparse operator (<a href="../refs/#LazyAlgebra.SparseOperators.SparseOperator"><code>SparseOperator</code></a>) in <code>LazyAlgebra</code> is the generalization of a sparse matrix.  Like a <a href="@ref"><code>GeneralMatrix</code></a>, rows and columns may be multi-dimensional.  However unlike a <a href="@ref"><code>GeneralMatrix</code></a>, a sparse operator only stores its <em>structural non-zero</em> entries and thus requires fewer memory and is usually faster to apply.</p><p>There are many different possibilities for storing a sparse operator, hence <code>SparseOperator{T,M,N}</code> is an abstract type inherited by the concrete types implementing compressed sparse storage in various formats.  Parameter <code>T</code> is the type of the elements while parameters <code>M</code> and <code>N</code> are the number of dimensions of the <em>rows</em> and of the <em>columns</em> respectively.  Objects of this kind are a generalization of sparse matrices in the sense that they implement linear mappings which can be applied to <code>N</code>-dimensional arguments to produce <code>M</code>-dimensional results (as explained below).  The construction of a sparse operator depends on its storage format.  Several concrete implementations are provided: <a href="#Compressed-sparse-row-format"><em>Compressed Sparse Row</em> (CSR)</a>, <a href="#Compressed-sparse-column-format"><em>Compressed Sparse Column</em> (CSC)</a> and <a href="#Compressed-sparse-coordinate-format"><em>Compressed Sparse Coordinate</em> (COO)</a>.</p><h2 id="Basic-methods"><a class="docs-heading-anchor" href="#Basic-methods">Basic methods</a><a id="Basic-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-methods" title="Permalink"></a></h2><p>The following methods are generally applicable to any sparse operator <code>A</code>:</p><ul><li><p><code>eltype(A)</code> yields <code>T</code>, the type of the elements of <code>A</code>;</p></li><li><p><code>row_size(A)</code> yields an <code>M</code>-tuple of <code>Int</code>: the size of the rows of <code>A</code>, this is equivalent to <code>output_size(A)</code>;</p></li><li><p><code>col_size(A)</code> yields an <code>N</code>tuple of <code>Int</code>: the size of the columns of <code>A</code>, this is equivalent to <code>input_size(A)</code>;</p></li><li><p><code>nrows(A)</code> yields <code>prod(row_size(A))</code>, the equivalent number of rows of <code>A</code>;</p></li><li><p><code>ncols(A)</code> yields <code>prod(col_size(A))</code>, the equivalent number of columns of <code>A</code>.</p></li><li><p><code>ndims(A)</code> yields <code>M + N</code> the number of dimensions of the regular array  corresponding to the sparse operator <code>A</code>;</p></li><li><p><code>size(A)</code> yields <code>(row_size(A)..., col_size(A)...)</code> the size of the regular  array corresponding to the sparse operator <code>A</code>;</p></li><li><p><code>length(A)</code> yields <code>prod(size(A))</code> the number of elements of the regular  array corresponding to the sparse operator <code>A</code>;</p></li><li><p><code>nnz(A)</code> yields the number of <em>structural non-zeros</em> in <code>A</code>;</p></li><li><p><code>nonzeros(A)</code> yields the vector of <em>structural non-zeros</em> in <code>A</code>.</p></li></ul><p>The <em>structural non-zeros</em> are the entries stored by the sparse structure, they may or not be equal to zero, un-stored entries are always considered as being equal to zero.</p><p>As can be seen above, <code>eltype</code>, <code>ndims</code>, <code>size</code> and <code>length</code> yield the same results as if applied to the multi-dimensional array corresponding to the sparse operator.</p><h2 id="Generalized-matrix-multplication-by-a-sparse-operator"><a class="docs-heading-anchor" href="#Generalized-matrix-multplication-by-a-sparse-operator">Generalized matrix multplication by a sparse operator</a><a id="Generalized-matrix-multplication-by-a-sparse-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-matrix-multplication-by-a-sparse-operator" title="Permalink"></a></h2><p>A sparse operator <code>A</code> can be directly used as any linear mapping in <code>LazyAlgebra</code>:</p><pre><code class="language-julia">A*x</code></pre><p>yields the generalized matrix multiplication of <code>x</code> by <code>A</code>.  The size of <code>x</code> must be that of the <em>columns</em> of <code>A</code>, that is <code>col_size(A)</code>.  The result is an array whose size is that of the <em>rows</em> of <code>A</code>, that is <code>size(A*x) = row_size(A)</code>.  Applying the adjoint of <code>A</code> is also implemented by the usual syntax:</p><pre><code class="language-julia">A&#39;*y</code></pre><p>to produce an array of size <code>col_size(A)</code> provided <code>y</code> is of suitable size, i.e. <code>size(y) = row_size(A)</code>.</p><p>Sparse operators can be used as iterators, the value returned by the iterator is a 3-tuple <code>(v,i,j)</code> with the value, the linear row index and the linear column index of the entry.  For instance:</p><pre><code class="language-julia">for (v,i,j) in A
    println(&quot;A[$i,$j] = $v&quot;)
end</code></pre><p>This can be used to illustrate how <code>w = A*x</code> and <code>z = A&#39;*y</code> could be computed for the sparse operator <code>A</code>:</p><pre><code class="language-julia"># Compute w = A*x:
@assert !Base.has_offset_axes(x)
@assert size(x) == col_size(A)
T = promote_type(eltype(A),eltype(x))
w = zeros(T, row_size(A))
@inbounds for (v,i,j) in A
    w[i] += v*x[j]
end</code></pre><p>and</p><pre><code class="language-julia"># Compute z = A&#39;*y:
@assert !Base.has_offset_axes(y)
@assert size(y) == row_size(A)
T = promote_type(eltype(A),eltype(y))
z = zeros(T, col_size(A))
@inbounds for (v,i,j) in A
    z[j] += conj(v)*y[i]
end</code></pre><p>Actual implementations of sparse operators in <code>LazyAlgebra</code> are equivalent to the above examples but should be more efficient because they exploit the specific storage format of a compressed sparse operator (see <a href="../refs/#LazyAlgebra.SparseOperators.CompressedSparseOperator"><code>CompressedSparseOperator</code></a>, <a href="../refs/#LazyAlgebra.SparseOperators.SparseOperatorCSR"><code>SparseOperatorCSR</code></a>, <a href="../refs/#LazyAlgebra.SparseOperators.SparseOperatorCSC"><code>SparseOperatorCSC</code></a> and <a href="../refs/#LazyAlgebra.SparseOperators.SparseOperatorCOO"><code>SparseOperatorCOO</code></a>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For now, row and column indices are restricted to be linear indices and arguments to the linear mappings implemented by compressed sparse operators must be arrays with conventional indexing (1-based linear indices) and preferably implementing linear indices (not Cartesian ones).</p></div></div><h2 id="Simple-construction-of-compressed-sparse-operators"><a class="docs-heading-anchor" href="#Simple-construction-of-compressed-sparse-operators">Simple construction of compressed sparse operators</a><a id="Simple-construction-of-compressed-sparse-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-construction-of-compressed-sparse-operators" title="Permalink"></a></h2><p>Compressed sparse operators only store their structural non-zero elements.  The abstract super-type of these sparse operators is <code>CompressedSparseOperator{F,T,M,N}</code> which is a direct sub-type of <code>SparseOperator{T,M,N}</code> with an additional parameter <code>F</code> to specify the storage format.  The parameter <code>F</code> is specificed as a symbol and can be:</p><ul><li><p><code>:COO</code> for <em>Compressed Sparse Coordinate</em> storage format.  This format is not the most efficient, it is mostly used as an intermediate for building a sparse operator in one of the following format.</p></li><li><p><code>:CSC</code> for <em>Compressed Sparse Column</em> storage format.  This format is very efficient for applying the adjoint of the sparse operator.</p></li><li><p><code>:CSR</code> for <em>Compressed Sparse Row</em> storage format.  This format is very efficient for directly applying the sparse operator.</p></li></ul><p>To construct a compressed sparse operator in a given format <code>F</code> from the values in a 2-dimensional array <code>A</code> call:</p><pre><code class="language-julia">CompressedSparseOperator{F}(A, sel = (v,i,j) -&gt; (v != zero(v)))</code></pre><p>where optional argument <code>sel</code> is a selector function which is called as <code>sel(v,i,j)</code> with <code>v</code>, <code>i</code> and <code>j</code> the value, the row and the column linear indices for each entries of <code>A</code> and which is assumed to yield <code>true</code> for the entries of <code>A</code> to be selected in the sparse structure and <code>false</code> for the entries of <code>A</code> to discard.  The default selector is such that all non-zeros of <code>A</code> are selected.  As an example, to select the non-zeros of the lower triangular part of <code>A</code>, the constructor can be called as:</p><pre><code class="language-julia">CompressedSparseOperator{F}(A, (v,i,j) -&gt; ((i ≥ j)&amp;(v != zero(v))))</code></pre><p>Note the (slight) optimization of the expression with a biwise AND <code>&amp;</code> instead of a short-circuiting logical AND <code>&amp;&amp;</code> to avoid branching.</p><p>By default the values of the structural non-zeros of the sparse operator have the same type as the elements of <code>A</code>, you can enforce a specific element type <code>T</code> with:</p><pre><code class="language-julia">CompressedSparseOperator{F,T}(A[, sel])</code></pre><p>To generalize the matrix-vector product, a sparse operator can emulate an array with more than 2 dimensions.  In that case, you must specify the number <code>M</code> of leading dimensions that are considered as the <em>rows</em>:</p><pre><code class="language-julia">CompressedSparseOperator{F,T,M}(A[, sel])</code></pre><p>The number <code>N</code> of trailing dimensions that are considered as the <em>columns</em> can also be specified (although they can be automatically guessed):</p><pre><code class="language-julia">CompressedSparseOperator{F,T,M,N}(A[, sel])</code></pre><p>with the restriction that <code>M ≥ 1</code>, <code>N ≥ 1</code> and <code>M + N = ndims(A)</code>.  Note that parameter <code>T</code> can be <code>Any</code> to keep the same element type as <code>A</code>.</p><p>Finally, the type <code>V</code> of the vector used to store the coefficients of the sparse operator may also be specified:</p><pre><code class="language-julia">CompressedSparseOperator{F,T,M,N,V}(A[, sel])</code></pre><p>with the restriction that <code>V</code> must have standard linear indexing.  The default is to take <code>V = Vector{T}</code>.  As a special case, you can choose a uniform boolean vector from the <a href="https://github.com/emmt/StructuredArrays.jl"><code>StructuredArrays</code></a> package to store the sparse coefficients:</p><pre><code class="language-julia">CompressedSparseOperator{F,T,M,N,UniformVector{Bool}}(A[, sel])</code></pre><p>yields a compressed sparse operator whose values are an immutable uniform vector of <code>true</code> values requiring no storage.  This is useful if you want to only store the sparse structure of the selected values, that is their indices in the compressed format <code>F</code> not their values.</p><p>As explained in the last sections, compressed sparse operators can also be consructed by providing the values of the structural non-zeros and their respective row and column indices.  As a general rule, to construct (or convert to) a sparse operator with compressed storage format <code>F</code>, you can call:</p><pre><code class="language-julia">CompressedSparseOperator{F}(args...; kwds...)
CompressedSparseOperator{F,T}(args...; kwds...)
CompressedSparseOperator{F,T,M}(args...; kwds...)
CompressedSparseOperator{F,T,M,N}(args...; kwds...)
CompressedSparseOperator{F,T,M,N,V}(args...; kwds...)</code></pre><p>where given parameters <code>T</code>, <code>M</code>, <code>N</code> and <code>V</code>, arguments <code>args...</code> and optional keywords <code>kwds...</code> will be passed to the concrete constructor <a href="../refs/#LazyAlgebra.SparseOperators.SparseOperatorCOO"><code>SparseOperatorCOO</code></a>, <a href="../refs/#LazyAlgebra.SparseOperators.SparseOperatorCSC"><code>SparseOperatorCSC</code></a> or <a href="../refs/#LazyAlgebra.SparseOperators.SparseOperatorCSR"><code>SparseOperatorCSR</code></a> corresponding to the format <code>F</code>.  For instance,</p><pre><code class="language-julia">CompressedSparseOperator{:CSR}(A) -&gt; SparseOperatorCSR(A)</code></pre><h2 id="Accessing-the-structural-non-zeros"><a class="docs-heading-anchor" href="#Accessing-the-structural-non-zeros">Accessing the structural non-zeros</a><a id="Accessing-the-structural-non-zeros-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-the-structural-non-zeros" title="Permalink"></a></h2><p>It is possible to use a compressed sparse operator <code>A</code> as an iterator:</p><pre><code class="language-julia">for (Aij,i,j) in A # simple but slow for CSR and CSC
    ...
end</code></pre><p>to retrieve the values <code>Aij</code> and respective row <code>i</code> and column <code>j</code> indices for all the entries stored in <code>A</code>.  It is however more efficient to access them according to their storage order which depends on the compressed format.</p><ul><li><p>If <code>A</code> is in CSC format:</p><pre><code class="language-julia">using LazyAlgebra.SparseMethods
for j in each_col(A)        # loop over column index
    for k in each_off(A, j) # loop over structural non-zeros in this column
        i   = get_row(A, k) # get row index of entry
        Aij = get_val(A, k) # get value of entry
     end
end</code></pre></li><li><p>If <code>A</code> is in CSR format:</p><pre><code class="language-julia">using LazyAlgebra.SparseMethods
for i in each_row(A)        # loop over row index
    for k in each_off(A, i) # loop over structural non-zeros in this row
        j   = get_col(A, k) # get column index of entry
        Aij = get_val(A, k) # get value of entry
     end
end</code></pre></li><li><p>If <code>A</code> is in COO format:</p><pre><code class="language-julia">using LazyAlgebra.SparseMethods
for k in each_off(A)
     i   = get_row(A, k) # get row index of entry
     j   = get_col(A, k) # get column index of entry
     Aij = get_val(A, k) # get value of entry
end</code></pre></li></ul><p>The low-level methods <code>each_row</code>, <code>each_col</code>, <code>each_off</code>, <code>get_row</code>, <code>get_col</code> and <code>get_val</code> are not automatically exported by <code>LazyAlgebra</code>, this is the purpose of the statement <code>using LazyAlgebra.SparseMethods</code>.  These methods may be extended to implement variants of compressed sparse operators.</p><h2 id="Sparse-operators-in-COO-format"><a class="docs-heading-anchor" href="#Sparse-operators-in-COO-format">Sparse operators in COO format</a><a id="Sparse-operators-in-COO-format-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-operators-in-COO-format" title="Permalink"></a></h2><p>Sparse operators in <em>Compressed Sparse Coordinate</em> (COO) format store the significant entries in no particular order, as a vector of values, a vector of linear row indices and a vector of linear column indices.  It is even possible to have repeated entries.  This format is very useful to build a sparse operator.  It can be converted to a more efficient format like <em>Compressed Sparse Column</em> or <em>Compressed Sparse Row</em> for fast application of the sparse linear mapping or of its adjoint.</p><p>A sparse operator in with COO storage can be directly constructed by:</p><pre><code class="language-julia">CompressedSparseOperator{:COO}(vals, rows, cols, rowsiz, colsiz)</code></pre><p>which is the same as:</p><pre><code class="language-julia">SparseOperatorCOO(vals, rows, cols, rowsiz, colsiz)</code></pre><p>or, if you want to force the element type of the result, one of the following:</p><pre><code class="language-julia">CompressedSparseOperator{:COO,T}(vals, rows, cols, rowsiz, colsiz)
SparseOperatorCOO{T}(vals, rows, cols, rowsiz, colsiz)</code></pre><p>Here, <code>vals</code> is the vector of values of the sparse entries, <code>rows</code> and <code>cols</code> are integer valued vectors with the linear row and column indices of the sparse entries, <code>rowsiz</code> and <code>colsiz</code> are the sizes of the row and column dimensions. The entries values and respective linear row and column indices of the <code>k</code>-th sparse entry are given by <code>vals[k]</code>, <code>rows[k]</code> and <code>cols[k]</code>.</p><p>For efficiency reasons, sparse operators are currently limited to <em>fast</em> arrays because they can be indexed linearly with no loss of performances.  If <code>vals</code>, <code>rows</code> and/or <code>cols</code> are not fast arrays, they will be automatically converted to linearly indexed arrays.</p><h2 id="Sparse-operators-in-CSC-format"><a class="docs-heading-anchor" href="#Sparse-operators-in-CSC-format">Sparse operators in CSC format</a><a id="Sparse-operators-in-CSC-format-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-operators-in-CSC-format" title="Permalink"></a></h2><p>Sparse operators in <em>Compressed Sparse Column</em> (CSC) format store the significant entries in a column-wise order, as a vector of values, a vector of corresponding linear row indices and a vector of offsets indicating, for each column, the range of indices in the vectors of values and of row indices.</p><p>A sparse operator in with CSC storage can be directly constructed by:</p><pre><code class="language-julia">CompressedSparseOperator{:CSC}(vals, rows, offs, rowsiz, colsiz)</code></pre><p>which is the same as:</p><pre><code class="language-julia">SparseOperatorCSC(vals, rows, offs, rowsiz, colsiz)</code></pre><p>or, if you want to force the element type of the result, one of the following:</p><pre><code class="language-julia">CompressedSparseOperator{:CSC,T}(vals, rows, offs, rowsiz, colsiz)
SparseOperatorCSC{T}(vals, rows, offs, rowsiz, colsiz)</code></pre><p>Here, <code>vals</code> is the vector of values of the sparse entries, <code>rows</code> is an integer valued vector of the linear row indices of the sparse entries, <code>offs</code> is a column-wise table of offsets in these arrays, <code>rowsiz</code> and <code>colsiz</code> are the sizes of the row and column dimensions.  The entries values and respective linear row indices of the <code>j</code>-th column are given by <code>vals[k]</code> and <code>rows[k]</code> with <code>k ∈ offs[j]+1:offs[j+1]</code>.  The linear column index <code>j</code> is in the range <code>1:n</code> where <code>n = prod(colsiz)</code> is the equivalent number of columns.</p><p>For efficiency reasons, sparse operators are currently limited to <em>fast</em> arrays because they can be indexed linearly with no loss of performances.  If <code>vals</code>, <code>rows</code> and/or <code>offs</code> are not fast arrays, they will be automatically converted to linearly indexed arrays.</p><h2 id="Sparse-operators-in-CSR-format"><a class="docs-heading-anchor" href="#Sparse-operators-in-CSR-format">Sparse operators in CSR format</a><a id="Sparse-operators-in-CSR-format-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-operators-in-CSR-format" title="Permalink"></a></h2><p>Sparse operators in <em>Compressed Sparse Row</em> (CSR) format store the significant entries in a row-wise order, as a vector of values, a vector of corresponding linear column indices and a vector of offsets indicating, for each row, the range of indices in the vectors of values and of column indices.</p><p>A sparse operator in with CSR storage can be directly constructed by:</p><pre><code class="language-julia">CompressedSparseOperator{:CSR}(vals, cols, offs, rowsiz, colsiz)</code></pre><p>which is the same as:</p><pre><code class="language-julia">SparseOperatorCSR(vals, cols, offs, rowsiz, colsiz)</code></pre><p>or, if you want to force the element type of the result, one of the following:</p><pre><code class="language-julia">CompressedSparseOperator{:CSR,T}(vals, cols, offs, rowsiz, colsiz)
SparseOperatorCSR{T}(vals, cols, offs, rowsiz, colsiz)</code></pre><p>Here, <code>vals</code> is the vector of values of the sparse entries, <code>cols</code> is an integer valued vector of the linear column indices of the sparse entries, <code>offs</code> is a column-wise table of offsets in these arrays, <code>rowsiz</code> and <code>colsiz</code> are the sizes of the row and column dimensions.  The entries values and respective linear column indices of the <code>i</code>-th row are given by <code>vals[k]</code> and <code>cols[k]</code> with <code>k ∈ offs[j]+1:offs[j+1]</code>.  The linear row index <code>i</code> is in the range <code>1:m</code> where <code>m = prod(rowsiz)</code> is the equivalent number of rows.</p><p>For efficiency reasons, sparse operators are currently limited to <em>fast</em> arrays because they can be indexed linearly with no loss of performances.  If <code>vals</code>, <code>cols</code> and/or <code>offs</code> are not fast arrays, they will be automatically converted to linearly indexed arrays.</p><h2 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h2><p>Calling a sparse operator constructor can also be used to convert between different formats or to change the type of the stored values.  For example, to convert a sparse operator <code>A</code> into a Compressed Spase Row (CSR) format, the following calls are equivalent:</p><pre><code class="language-julia">SparseOperatorCSR(A)
CompressedSparseOperator{:CSR}(A)
convert(SparseOperatorCSR, A)
convert(CompressedSparseOperator{:CSR}, A)</code></pre><p>If <code>A</code> is in Compressed Sparse Coordinate (COO) format, entries are sorted and duplicates merged.  This also occurs when converting from COO format to Compressed Sparse Column (CSC) format.  Such conversions are very useful as building a sparse operator in COO format is easier while CSC and CSR formats are more efficients.</p><p>It is sufficient to specify the element type <code>T</code> to convert the storage format and the type of the stored values.  For example, any of the following will convert <code>A</code> to CSC format with element type <code>T</code>:</p><pre><code class="language-julia">SparseOperatorCSC{T}(A)
CompressedSparseOperator{:CSC,T}(A)
convert(SparseOperatorCSC{T}, A)
convert(CompressedSparseOperator{:CSC,T}, A)</code></pre><p>If you just want to convert the type of the values stored by the sparse operator <code>A</code> to type <code>T</code> while keeping its storage format, any of the following will do the job:</p><pre><code class="language-julia">SparseOperator{T}(A)
CompressedSparseOperator{Any,T}(A)
convert(SparseOperator{T}, A)
convert(CompressedSparseOperator{Any,T}, A)</code></pre><p>As can be seen, specifying <code>Any</code> for the format parameter in <code>CompressedSparseOperator</code> is a mean to keep the same storage format.</p><h2 id="Other-methods"><a class="docs-heading-anchor" href="#Other-methods">Other methods</a><a id="Other-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Other-methods" title="Permalink"></a></h2><p>A sparse operator <code>S</code> can be reshaped:</p><pre><code class="language-julia">reshape(S, rowdims, coldims)</code></pre><p>where <code>rowdims</code> and <code>coldims</code> are the new list of dimensions for the rows and the columns, their product must be equal to the product of the former lists of dimensions (which means that you cannot change the number of elements of the input and output of a sparse operator).  The reshaped sparse operator and <code>S</code> share the arrays of non-zero coefficients and corresponding row and column indices, hence reshaping is a fast operation.</p><p>The non-zero coefficients of a sparse operator <code>S</code> can be unpacked into a provided array <code>A</code>:</p><pre><code class="language-julia">unpack!(A, S; flatten=false) -&gt; A</code></pre><p>Keyword <code>flatten</code> specifies whether to only consider the length of <code>A</code> instead of its dimensions.  In any cases, <code>A</code> must have as many elements as <code>length(S)</code> and standard linear indexing.  Just call <code>Array(S)</code> to unpack the coefficients of the sparse operator <code>S</code> without providing the destination array or <code>Array{T}(S)</code> if you want to a specific element type <code>T</code>.</p><p>[LinearInterpolators]: https://github.com/emmt/LinearInterpolators.jl [SparseArrays]: https://docs.julialang.org/en/latest/stdlib/SparseArrays/#Sparse-Arrays-1 [sparse]: https://docs.julialang.org/en/latest/stdlib/SparseArrays/#SparseArrays.sparse [SparseMatrixCSC]: https://docs.julialang.org/en/latest/stdlib/SparseArrays/#SparseArrays.SparseMatrixCSC</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../vectors/">« Methods for vectors</a><a class="docs-footer-nextpage" href="../mappings/">Methods for mappings »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 28 February 2021 11:48">Sunday 28 February 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
