<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods for mappings · LazyAlgebra for Julia</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LazyAlgebra for Julia</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../install/">Installation</a></li><li><a class="toctext" href="../introduction/">Lazy algebra framework</a></li><li><a class="toctext" href="../vectors/">Methods for vectors</a></li><li class="current"><a class="toctext" href>Methods for mappings</a><ul class="internal"><li><a class="toctext" href="#The-vcreate-method-1">The <code>vcreate</code> method</a></li><li><a class="toctext" href="#The-apply!-method-1">The <code>apply!</code> method</a></li><li><a class="toctext" href="#Example-1">Example</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Methods for mappings</a></li></ul><a class="edit-page" href="https://github.com/emmt/LazyAlgebra.jl/blob/master/docs/src/mappings.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Methods for mappings</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Methods-for-mappings-1" href="#Methods-for-mappings-1">Methods for mappings</a></h1><p><code>LazyAlgebra</code> provides a number of mappings and linear operators.  To create new primitive mapping types (not by combining existing mappings) and benefit from the <code>LazyAlgebra</code> infrastruture, you have to:</p><ul><li><p>Create a new type derived from <code>Mapping</code> or one of its abstract subtypes such as <code>LinearMapping</code>.</p></li><li><p>Implement at least two methods <code>apply!</code> and <code>vcreate</code> specialized for the new mapping type.  Applying the mapping is done by the former method.  The latter method is called to create a new output variable suitable to store the result of applying the mapping (or one of its variants) to some input variable.</p></li></ul><h2><a class="nav-anchor" id="The-vcreate-method-1" href="#The-vcreate-method-1">The <code>vcreate</code> method</a></h2><p>The signature of the <code>vcreate</code> method is:</p><pre><code class="language-julia">vcreate(::Type{P}, A::Ta, x::Tx, scratch::Bool=false) -&gt; y</code></pre><p>where <code>A</code> is the mapping, <code>x</code> its argument and <code>P</code> is one of <code>Direct</code>, <code>Adjoint</code>, <code>Inverse</code> and/or <code>InverseAdjoint</code> (or equivalently <code>AdjointInverse</code>) and indicates how <code>A</code> is to be applied:</p><ul><li><code>Direct</code> to apply <code>A</code> to <code>x</code>, <em>e.g.</em> to compute <code>A⋅x</code>;</li><li><code>Adjoint</code> to apply the adjoint of <code>A</code> to <code>x</code>, <em>e.g.</em> to compute <code>A&#39;⋅x</code>;</li><li><code>Inverse</code> to apply the inverse of <code>A</code> to <code>x</code>, <em>e.g.</em> to compute <code>A\x</code>;</li><li><code>InverseAdjoint</code> or <code>AdjointInverse</code> to apply the inverse of <code>A&#39;</code> to <code>x</code>, <em>e.g.</em> to compute <code>A&#39;\x</code>.</li></ul><p>The result returned by <code>vcreate</code> is a new output variables suitable to store the result of applying the mapping <code>A</code> (or one of its variants as indicated by <code>P</code>) to the input variables <code>x</code>.</p><p>The optional argument <code>scratch</code> is a boolean to let the caller indicate whether the input variable <code>x</code> may be re-used to store the result.  If <code>scratch</code> is <code>true</code> and if that make sense, the value returned by <code>vcreate</code> may be <code>x</code>.  The default value of <strong><code>scratch</code> must be <code>false</code></strong>.  Calling <code>vcreate</code> with <code>scratch=true</code> can be used to limit the allocation of resources when possible. Having <code>scratch=true</code> is only indicative and a specific implementation of <code>vcreate</code> may legitimately always assume <code>scratch=false</code> and return a new variable whatever the value of this argument (e.g. because applying the considered mapping <em>in-place</em> is not possible or because the considered mapping is not an endomorphism).  Of course, the opposite behavior (i.e., assuming that <code>scratch=true</code> while the method was called with <code>scratch=false</code>) is forbidden.</p><h2><a class="nav-anchor" id="The-apply!-method-1" href="#The-apply!-method-1">The <code>apply!</code> method</a></h2><p>The signature of the <code>apply!</code> method is:</p><pre><code class="language-julia">apply!(α::Real, ::Type{P}, A::Ta, x::Tx, scratch::Bool=false, β::Real, y::Ty) -&gt; y</code></pre><p>This method shall overwrites the contents of output variables <code>y</code> with the result of <code>α*P(A)⋅x + β*y</code> where <code>P</code> is one of <code>Direct</code>, <code>Adjoint</code>, <code>Inverse</code> and/or <code>InverseAdjoint</code> (or equivalently <code>AdjointInverse</code>) and shall return <code>y</code>.  The convention is that the prior contents of <code>y</code> is not used at all if <code>β = 0</code> so the contents of <code>y</code> does not need to be initialized in that case.</p><p>Not all operations <code>P</code> must be implemented, only the supported ones.  For iterative resolution of (inverse) problems, it is generally needed to implement at least the <code>Direct</code> and <code>Adjoint</code> operations for linear operators.  However nonlinear mappings are not supposed to implement the <code>Adjoint</code> and derived operations.</p><p>Argument <code>scratch</code> is a boolean to let the caller indicate whether the contents of the input variable <code>x</code> may be overwritten during the operations.  If <code>scratch=false</code>, the <code>apply!</code> method shall not modify the contents of <code>x</code>.</p><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>The following example implements a simple sparse linear operator which is able to operate on multi-dimensional arrays (the so-called <em>variables</em>):</p><pre><code class="language-julia">using LazyAlgebra
import LazyAlgebra: vcreate, apply!, input_size, output_size

struct SparseOperator{T&lt;:AbstractFloat,M,N} &lt;: LinearMapping
    outdims::NTuple{M,Int}
    inpdims::NTuple{N,Int}
    A::Vector{T}
    I::Vector{Int}
    J::Vector{Int}
end

input_size(S::SparseOperator) = S.inpdims
output_size(S::SparseOperator) = S.outdims

function vcreate(::Type{Direct}, S::SparseOperator{Ts,M,N},
                 x::DenseArray{Tx,N}) where {Ts&lt;:Real,Tx&lt;:Real,M,N}
    @assert size(x) == input_size(S)
    Ty = promote_type(Ts, Tx)
    return Array{Ty}(undef, output_size(S))
end

function vcreate(::Type{Adjoint}, S::SparseOperator{Ts,M,N},
                 x::DenseArray{Tx,M}) where {Ts&lt;:Real,Tx&lt;:Real,M,N}
    @assert size(x) == output_size(S)
    Ty = promote_type(Ts, Tx)
    return Array{Ty}(undef, input_size(S))
end

function apply!(alpha::Real,
                ::Type{Direct},
                S::SparseOperator{Ts,M,N},
                x::DenseArray{Tx,N},
                beta::Real,
                y::DenseArray{Ty,M}) where {Ts&lt;:Real,Tx&lt;:Real,Ty&lt;:Real,M,N}
    @assert size(x) == input_size(S)
    @assert size(y) == output_size(S)
    beta == 1 || vscale!(y, beta)
    if alpha != 0
        A, I, J = S.A, S.I, S.J
        _alpha_ = convert(promote_type(Ts,Tx,Ty), alpha)
        @assert length(I) == length(J) == length(A)
        for k in 1:length(A)
            i, j = I[k], J[k]
            y[i] += _alpha_*A[k]*x[j]
        end
    end
    return y
end

function apply!(alpha::Real, ::Type{Adjoint},
                S::SparseOperator{Ts,M,N},
                x::DenseArray{Tx,M},
                beta::Real,
                y::DenseArray{Ty,N}) where {Ts&lt;:Real,Tx&lt;:Real,Ty&lt;:Real,M,N}
    @assert size(x) == output_size(S)
    @assert size(y) == input_size(S)
    beta == 1 || vscale!(y, beta)
    if alpha != 0
        A, I, J = S.A, S.I, S.J
        _alpha_ = convert(promote_type(Ts,Tx,Ty), alpha)
        @assert length(I) == length(J) == length(A)
        for k in 1:length(A)
            i, j = I[k], J[k]
            y[j] += _alpha_*A[k]*x[i]
        end
    end
    return y
end</code></pre><p>Remarks:</p><ul><li><p>In our example, arrays are restricted to be <em>dense</em> so that linear indexing is efficient.  For the sake of clarity, the above code is intended to be correct although there are many possible optimizations.</p></li><li><p>If <code>alpha = 0</code> there is nothing to do except scale <code>y</code> by <code>beta</code>.</p></li><li><p>The call to <code>vscale!(beta, y)</code> is to properly initialize <code>y</code>.  Remember the convention that the contents of <code>y</code> is not used at all if <code>beta = 0</code> so <code>y</code> does not need to be properly initialized in that case, it will simply be zero-filled by the call to <code>vscale!</code>.  The statements</p><pre><code class="language-julia">beta == 1 || vscale!(y, beta)</code></pre><p>are equivalent to:</p><pre><code class="language-julia">if beta != 1
    vscale!(y, beta)
end</code></pre><p>which may be simplified to just calling <code>vscale!</code> unconditionally:</p><pre><code class="language-julia">vscale!(y, beta)</code></pre><p>as <code>vscale!(y, beta)</code> does nothing if <code>beta = 1</code>.</p></li><li><p><code>@inbounds</code> could be used for the loops but this would require checking that all indices are whithin the bounds.  In this example, only <code>k</code> is guaranteed to be valid, <code>i</code> and <code>j</code> have to be checked.</p></li></ul><footer><hr/><a class="previous" href="../vectors/"><span class="direction">Previous</span><span class="title">Methods for vectors</span></a></footer></article></body></html>
