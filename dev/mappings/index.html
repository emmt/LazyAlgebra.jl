<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods for mappings · LazyAlgebra for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LazyAlgebra for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../introduction/">Lazy algebra framework</a></li><li><a class="tocitem" href="../vectors/">Methods for vectors</a></li><li><a class="tocitem" href="../sparse/">Sparse operators</a></li><li class="is-active"><a class="tocitem" href>Methods for mappings</a><ul class="internal"><li><a class="tocitem" href="#The-vcreate-method-1"><span>The <code>vcreate</code> method</span></a></li><li><a class="tocitem" href="#The-apply!-method-1"><span>The <code>apply!</code> method</span></a></li><li><a class="tocitem" href="#The-are_same_mappings-method-1"><span>The <code>are_same_mappings</code> method</span></a></li><li><a class="tocitem" href="#Example-1"><span>Example</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods for mappings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods for mappings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LazyAlgebra.jl/blob/master/docs/src/mappings.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods-for-mappings-1"><a class="docs-heading-anchor" href="#Methods-for-mappings-1">Methods for mappings</a><a class="docs-heading-anchor-permalink" href="#Methods-for-mappings-1" title="Permalink"></a></h1><p><code>LazyAlgebra</code> provides a number of mappings and linear operators.  To create new primitive mapping types (not by combining existing mappings) and benefit from the <code>LazyAlgebra</code> infrastruture, you have to:</p><ul><li><p>Create a new type derived from <code>Mapping</code> or one of its abstract sub-types such as <code>LinearMapping</code>.</p></li><li><p>Implement at least two methods <code>apply!</code> and <code>vcreate</code> specialized for the new mapping type.  Applying the mapping is done by the former method.  The latter method is called to create a new output variable suitable to store the result of applying the mapping (or one of its variants) to some input variable.</p></li><li><p>Optionally specialize method <code>are_same_mappings</code> for two arguments of the new mapping type.</p></li></ul><h2 id="The-vcreate-method-1"><a class="docs-heading-anchor" href="#The-vcreate-method-1">The <code>vcreate</code> method</a><a class="docs-heading-anchor-permalink" href="#The-vcreate-method-1" title="Permalink"></a></h2><p>The signature of the <code>vcreate</code> method to be implemented by specific mapping types is:</p><pre><code class="language-julia">vcreate(::Type{P}, A::Ta, x::Tx, scratch::Bool) -&gt; y</code></pre><p>where <code>A</code> is the mapping, <code>x</code> its argument and <code>P</code> is one of <code>Direct</code>, <code>Adjoint</code>, <code>Inverse</code> and/or <code>InverseAdjoint</code> (or equivalently <code>AdjointInverse</code>) and indicates how <code>A</code> is to be applied:</p><ul><li><code>Direct</code> to apply <code>A</code> to <code>x</code>, <em>e.g.</em> to compute <code>A⋅x</code>;</li><li><code>Adjoint</code> to apply the adjoint of <code>A</code> to <code>x</code>, <em>e.g.</em> to compute <code>A&#39;⋅x</code>;</li><li><code>Inverse</code> to apply the inverse of <code>A</code> to <code>x</code>, <em>e.g.</em> to compute <code>A\x</code>;</li><li><code>InverseAdjoint</code> or <code>AdjointInverse</code> to apply the inverse of <code>A&#39;</code> to <code>x</code>, <em>e.g.</em> to compute <code>A&#39;\x</code>.</li></ul><p>The result returned by <code>vcreate</code> is a new output variables suitable to store the result of applying the mapping <code>A</code> (or one of its variants as indicated by <code>P</code>) to the input variables <code>x</code>.</p><p>The <code>scratch</code> argument is a boolean to let the caller indicate whether the input variable <code>x</code> may be re-used to store the result.  If <code>scratch</code> is <code>true</code> and if that make sense, the value returned by <code>vcreate</code> may be <code>x</code>. Calling <code>vcreate</code> with <code>scratch=true</code> can be used to limit the allocation of resources when possible.  Having <code>scratch=true</code> is only indicative and a specific implementation of <code>vcreate</code> may legitimately always assume <code>scratch=false</code> and return a new variable whatever the value of this argument (e.g. because applying the considered mapping <em>in-place</em> is not possible or because the considered mapping is not an endomorphism).  Of course, the opposite behavior (i.e., assuming that <code>scratch=true</code> while the method was called with <code>scratch=false</code>) is forbidden.</p><p>The result returned by <code>vcreate</code> should be of predictible type to ensure <em>type-stability</em>.  Checking the validity (<em>e.g.</em> the size) of argument <code>x</code> in <code>vcreate</code> may be skipped because this argument will be eventually checked by the <code>apply!</code> method.</p><h2 id="The-apply!-method-1"><a class="docs-heading-anchor" href="#The-apply!-method-1">The <code>apply!</code> method</a><a class="docs-heading-anchor-permalink" href="#The-apply!-method-1" title="Permalink"></a></h2><p>The signature of the <code>apply!</code> method to be implemented by specific mapping types is:</p><pre><code class="language-julia">apply!(α::Number, ::Type{P}, A::Ta, x::Tx, scratch::Bool, β::Number, y::Ty) -&gt; y</code></pre><p>This method shall overwrites the contents of output variables <code>y</code> with the result of <code>α*P(A)⋅x + β*y</code> where <code>P</code> is one of <code>Direct</code>, <code>Adjoint</code>, <code>Inverse</code> and/or <code>InverseAdjoint</code> (or equivalently <code>AdjointInverse</code>) and shall return <code>y</code>.  The convention is that the prior contents of <code>y</code> is not used at all if <code>β = 0</code> so the contents of <code>y</code> does not need to be initialized in that case.</p><p>Not all operations <code>P</code> must be implemented, only the supported ones.  For iterative resolution of (inverse) problems, it is generally needed to implement at least the <code>Direct</code> and <code>Adjoint</code> operations for linear operators.  However nonlinear mappings are not supposed to implement the <code>Adjoint</code> and derived operations.</p><p>Argument <code>scratch</code> is a boolean to let the caller indicate whether the contents of the input variable <code>x</code> may be overwritten during the operations.  If <code>scratch=false</code>, the <code>apply!</code> method shall not modify the contents of <code>x</code>.</p><h2 id="The-are_same_mappings-method-1"><a class="docs-heading-anchor" href="#The-are_same_mappings-method-1">The <code>are_same_mappings</code> method</a><a class="docs-heading-anchor-permalink" href="#The-are_same_mappings-method-1" title="Permalink"></a></h2><p>The method <code>are_same_mappings(A,B)</code> yields whether <code>A</code> and <code>B</code> are the same mappings in the sense that their effects will <strong>always</strong> be the same.  This method is used to perform some simplifications and optimizations and may have to be specialized for specific mapping types.  The default implementation is to return <code>A === B</code>.</p><p>The returned result may be true although <code>A</code> and <code>B</code> are not necessarily the same object.  In the below example, if <code>A</code> and <code>B</code> are two sparse matrices whose coefficients and indices are stored in the same vectors (as can be tested with the <code>===</code> operator) this method should return <code>true</code> because the two operators will behave identically (any changes in the coefficients or indices of <code>A</code> will be reflected in <code>B</code>).  If any of the vectors storing the coefficients or the indices are not the same objects, then <code>are_same_mappings(A,B)</code> must return <code>false</code> even though the stored values may be the same because it is possible, later, to change one operator without affecting identically the other.</p><h2 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h2><p>The following example implements a simple sparse linear operator which is able to operate on multi-dimensional arrays (the so-called <em>variables</em>):</p><pre><code class="language-julia"># Use LazyAlgebra framework and import methods that need to be extended.
using LazyAlgebra
import LazyAlgebra: vcreate, apply!, input_size, output_size

struct SparseOperator{T&lt;:AbstractFloat,M,N} &lt;: LinearMapping
    outdims::NTuple{M,Int}
    inpdims::NTuple{N,Int}
    A::Vector{T}
    I::Vector{Int}
    J::Vector{Int}
end

input_size(S::SparseOperator) = S.inpdims
output_size(S::SparseOperator) = S.outdims

function vcreate(::Type{Direct}, S::SparseOperator{Ts,M,N},
                 x::DenseArray{Tx,N},
                 scratch::Bool) where {Ts&lt;:Real,Tx&lt;:Real,M,N}
    @assert size(x) == input_size(S)
    Ty = promote_type(Ts, Tx)
    return Array{Ty}(undef, output_size(S))
end

function vcreate(::Type{Adjoint}, S::SparseOperator{Ts,M,N},
                 x::DenseArray{Tx,M},
                 scratch::Bool) where {Ts&lt;:Real,Tx&lt;:Real,M,N}
    @assert size(x) == output_size(S)
    Ty = promote_type(Ts, Tx)
    return Array{Ty}(undef, input_size(S))
end

function apply!(α::Real,
                ::Type{Direct},
                S::SparseOperator{Ts,M,N},
                x::DenseArray{Tx,N},
                scratch::Bool,
                β::Real,
                y::DenseArray{Ty,M}) where {Ts&lt;:Real,Tx&lt;:Real,Ty&lt;:Real,M,N}
    @assert size(x) == input_size(S)
    @assert size(y) == output_size(S)
    β == 1 || vscale!(y, β)
    if α != 0
        A, I, J = S.A, S.I, S.J
        alpha = convert(promote_type(Ts,Tx,Ty), α)
        @assert length(I) == length(J) == length(A)
        for k in 1:length(A)
            i, j = I[k], J[k]
            y[i] += alpha*A[k]*x[j]
        end
    end
    return y
end

function apply!(α::Real,
                ::Type{Adjoint},
                S::SparseOperator{Ts,M,N},
                x::DenseArray{Tx,M},
                scratch::Bool,
                β::Real,
                y::DenseArray{Ty,N}) where {Ts&lt;:Real,Tx&lt;:Real,Ty&lt;:Real,M,N}
    @assert size(x) == output_size(S)
    @assert size(y) == input_size(S)
    β == 1 || vscale!(y, β)
    if α != 0
        A, I, J = S.A, S.I, S.J
        alpha = convert(promote_type(Ts,Tx,Ty), α)
        @assert length(I) == length(J) == length(A)
        for k in 1:length(A)
            i, j = I[k], J[k]
            y[j] += alpha*A[k]*x[i]
        end
    end
    return y
end

are_same_mappings(A::T, B::T) where {T&lt;:SparseOperator} =
    (A.outdims == B.outdims &amp;&amp; A.inpdims == B.inpdims &amp;&amp;
     A.A === B.A &amp;&amp; A.I === B.I &amp;&amp; A.J === B.J)</code></pre><p>Remarks:</p><ul><li><p>In our example, arrays are restricted to be <em>dense</em> so that linear indexing is efficient.  For the sake of clarity, the above code is intended to be correct although there are many possible optimizations.</p></li><li><p>If <code>α = 0</code> there is nothing to do except scale <code>y</code> by <code>β</code>.</p></li><li><p>The call to <code>vscale!(β, y)</code> is to properly initialize <code>y</code>.  Remember the convention that the contents of <code>y</code> is not used at all if <code>β = 0</code> so <code>y</code> does not need to be properly initialized in that case, it will simply be zero-filled by the call to <code>vscale!</code>.  The statements</p><pre><code class="language-julia">β == 1 || vscale!(y, β)</code></pre><p>are equivalent to:</p><pre><code class="language-julia">if β != 1
    vscale!(y, β)
end</code></pre><p>which may be simplified to just calling <code>vscale!</code> unconditionally:</p><pre><code class="language-julia">vscale!(y, β)</code></pre><p>as <code>vscale!(y, β)</code> does nothing if <code>β = 1</code>.</p></li><li><p><code>@inbounds</code> could be used for the loops but this would require checking that all indices are whithin the bounds.  In this example, only <code>k</code> is guaranteed to be valid, <code>i</code> and <code>j</code> have to be checked.</p></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sparse/">« Sparse operators</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 June 2020 09:34">Thursday 11 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
