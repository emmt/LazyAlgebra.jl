<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · LazyAlgebra for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LazyAlgebra for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../introduction/">Lazy algebra framework</a></li><li><a class="tocitem" href="../vectors/">Methods for vectors</a></li><li><a class="tocitem" href="../sparse/">Sparse operators</a></li><li><a class="tocitem" href="../mappings/">Methods for mappings</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Methods-for-linear-mappings"><span>Methods for linear mappings</span></a></li><li><a class="tocitem" href="#Sparse-operators"><span>Sparse operators</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/LazyAlgebra.jl/blob/master/docs/src/refs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>The following provides detailled documentation about types and methods provided by the <code>LazyAlgebra</code> package.  This information is also available from the REPL by typing <code>?</code> followed by the name of a method or a type.</p><h2 id="Methods-for-linear-mappings"><a class="docs-heading-anchor" href="#Methods-for-linear-mappings">Methods for linear mappings</a><a id="Methods-for-linear-mappings-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-linear-mappings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.nrows" href="#LazyAlgebra.nrows"><code>LazyAlgebra.nrows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nrows(A)</code></pre><p>yields the <em>equivalent</em> number of rows of the linear operator <code>A</code>.  Not all operators extend this method.</p><p>In the implemented generalization of linear operators, the equivalent number of rows is the number of element of the result of applying the operator be it single- or multi-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/methods.jl#L321-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.ncols" href="#LazyAlgebra.ncols"><code>LazyAlgebra.ncols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ncols(A)</code></pre><p>yields the <em>equivalent</em> number of columns of the linear operator <code>A</code>.  Not all operators extend this method.</p><p>In the implemented generalization of linear operators, the equivalent number of columns is the number of element of an argument of the operator be it single- or multi-dimensional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/methods.jl#L336-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.row_size" href="#LazyAlgebra.row_size"><code>LazyAlgebra.row_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">row_size(A)</code></pre><p>yields the dimensions of the result of applying the linear operator <code>A</code>, this is equivalent to <code>output_size(A)</code>.  Not all operators extend this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/methods.jl#L351-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.col_size" href="#LazyAlgebra.col_size"><code>LazyAlgebra.col_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">col_size(A)</code></pre><p>yields the dimensions of the argument of the linear operator <code>A</code>, this is equivalent to <code>input_size(A)</code>.  Not all operators extend this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/methods.jl#L362-L369">source</a></section></article><h2 id="Sparse-operators"><a class="docs-heading-anchor" href="#Sparse-operators">Sparse operators</a><a id="Sparse-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-operators" title="Permalink"></a></h2><h3 id="Types-and-compressed-storage-formats"><a class="docs-heading-anchor" href="#Types-and-compressed-storage-formats">Types and compressed storage formats</a><a id="Types-and-compressed-storage-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-compressed-storage-formats" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.SparseOperator" href="#LazyAlgebra.SparseOperators.SparseOperator"><code>LazyAlgebra.SparseOperators.SparseOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SparseOperator{T,M,N}</code> is the abstract type inherited by the sparse operator types. Parameter <code>T</code> is the type of the elements.  Parameters <code>M</code> and <code>N</code> are the number of dimensions of the <em>rows</em> and of the <em>columns</em> respectively. Sparse operators are a generalization of sparse matrices in the sense that they implement linear mappings which can be applied to <code>N</code>-dimensonal arguments to produce <code>M</code>-dimensional results (as explained below).  See <a href="@ref"><code>GeneralMatrix</code></a> for a similar generalization but for <em>dense</em> matrices.</p><p>See <a href="#LazyAlgebra.SparseOperators.CompressedSparseOperator"><code>CompressedSparseOperator</code></a> for usage of sparse operators implementing compressed storage formats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L124-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.CompressedSparseOperator" href="#LazyAlgebra.SparseOperators.CompressedSparseOperator"><code>LazyAlgebra.SparseOperators.CompressedSparseOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CompressedSparseOperator{F,T,M,N}</code> is an abstract sub-type of <code>SparseOperator{T,M,N}</code> and is inherited by the concrete types implementing sparse operators with compressed storage in format <code>F</code>.</p><p>Format <code>F</code> is specificed as a symbol and can be:</p><ul><li><p><code>:COO</code> for <em>Compressed Sparse Coordinate</em> storage format.  This format is not the most efficient, it is mostly used as an intermediate for building a sparse operator in one of the following formats.</p></li><li><p><code>:CSC</code> for <em>Compressed Sparse Column</em> storage format.  This format is very efficient for applying the adjoint of the sparse operator.</p></li><li><p><code>:CSR</code> for <em>Compressed Sparse Row</em> storage format.  This format is very efficient for directly applying the sparse operator.</p></li></ul><p>To construct (or convert to) a sparse operator with compressed storage format <code>F</code>, you can call:</p><pre><code class="language-none">CompressedSparseOperator{F}(args...; kwds...)
CompressedSparseOperator{F,T}(args...; kwds...)
CompressedSparseOperator{F,T,M}(args...; kwds...)
CompressedSparseOperator{F,T,M,N}(args...; kwds...)</code></pre><p>where given parameters <code>T</code>, <code>M</code> and <code>N</code>, arguments <code>args...</code> and optional keywords <code>kwds...</code> will be passed to the concrete constructor <a href="#LazyAlgebra.SparseOperators.SparseOperatorCOO"><code>SparseOperatorCOO</code></a>, <a href="#LazyAlgebra.SparseOperators.SparseOperatorCSC"><code>SparseOperatorCSC</code></a> or <a href="#LazyAlgebra.SparseOperators.SparseOperatorCSR"><code>SparseOperatorCSR</code></a> corresponding to the format <code>F</code>.</p><p>It is possible to use a compressed sparse operator <code>A</code> as an iterator:</p><pre><code class="language-julia">for (Aij,i,j) in A # simple but slow for CSR and CSC
    ...
end</code></pre><p>to retrieve the values <code>Aij</code> and respective row <code>i</code> and column <code>j</code> indices for all the entries stored in <code>A</code>.  It is however more efficient to access them according to their storage order which depends on the compressed format.</p><ul><li><p>If <code>A</code> is in CSC format:</p><pre><code class="language-julia">using LazyAlgebra.SparseMethods
for j in each_col(A)        # loop over column index
    for k in each_off(A, j) # loop over structural non-zeros in this column
        i   = get_row(A, k) # get row index of entry
        Aij = get_val(A, k) # get value of entry
     end
end</code></pre></li><li><p>If <code>A</code> is in CSR format:</p><pre><code class="language-julia">using LazyAlgebra.SparseMethods
for i in each_row(A)        # loop over row index
    for k in each_off(A, i) # loop over structural non-zeros in this row
        j   = get_col(A, k) # get column index of entry
        Aij = get_val(A, k) # get value of entry
     end
end</code></pre></li><li><p>If <code>A</code> is in COO format:</p><pre><code class="language-julia">using LazyAlgebra.SparseMethods
for k in each_off(A)
     i   = get_row(A, k) # get row index of entry
     j   = get_col(A, k) # get column index of entry
     Aij = get_val(A, k) # get value of entry
end</code></pre></li></ul><p>The low-level methods <code>each_row</code>, <code>each_col</code>, <code>each_off</code>, <code>get_row</code>, <code>get_col</code> and <code>get_val</code> are not automatically exported by <code>LazyAlgebra</code>, this is the purpose of the statement <code>using LazyAlgebra.SparseMethods</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L140-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.SparseOperatorCOO" href="#LazyAlgebra.SparseOperators.SparseOperatorCOO"><code>LazyAlgebra.SparseOperators.SparseOperatorCOO</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sparse operators in <em>Compressed Sparse Coordinate</em> (COO) format store the significant entries in no particular order, as a vector of values, a vector of linear row indices and a vector of linear column indices. It is even possible to have repeated entries. This format is very useful to build a sparse linear operator. It can be converted to a more efficient format like <em>Compressed Sparse Column</em> (CSC) or <em>Compressed Sparse Row</em> (CSR) for fast application of the sparse linear mapping or of its adjoint.</p><p>A sparse operator in COO storage format can be constructed by providing all necessary information:</p><pre><code class="language-none">SparseOperatorCOO(vals, rows, cols, rowsiz, colsiz)</code></pre><p>where <code>vals</code> is the vector of values of the sparse entries, <code>rows</code> and <code>cols</code> are integer valued vectors with the linear row and column indices of the sparse entries, <code>rowsiz</code> and <code>colsiz</code> are the sizes of the row and column dimensions. The entries values and respective linear row and column indices of the <code>k</code>-th sparse entry are given by <code>vals[k]</code>, <code>rows[k]</code> and <code>cols[k]</code>.  For efficiency reasons, sparse operators are currently limited to <em>fast</em> arrays because they can be indexed linearly with no loss of performances.  If <code>vals</code>, <code>rows</code> and/or <code>cols</code> are not fast arrays, they will be automatically converted to linearly indexed arrays.</p><p>A sparse operator in COO storage format can be directly constructed from a 2-dimensional Julia array <code>A</code>:</p><pre><code class="language-none">SparseOperatorCOO(A, sel = (v,i,j) -&gt; (v != zero(v)))</code></pre><p>where optional argument <code>sel</code> is a selector function which is called as <code>sel(v,i,j)</code> with <code>v</code>, <code>i</code> and <code>j</code> the value, the row and the column linear indices for each entries of <code>A</code> and which is assumed to yield <code>true</code> for the entries of <code>A</code> to be selected in the sparse structure and <code>false</code> for the entries of <code>A</code> to discard.  The default selector is such that all non-zeros of <code>A</code> are selected.</p><p>The element type, say <code>T</code>, for the sparse coefficients can be imposed by rewriting the above examples as:</p><pre><code class="language-none">SparseOperatorCOO{T}(args...)</code></pre><p>A sparse operator in COO storage format implementing generalized matrix-vector multiplication can also be directly constructed from a <code>L</code>-dimensional Julia array (with <code>L ≥ 2</code>) <code>A</code> by:</p><pre><code class="language-none">SparseOperatorCOO{T,M}(A[, sel])</code></pre><p>with <code>M</code> the number of leading dimensions of <code>A</code> corresponding to the <em>rows</em> of the operator, the trailing <code>N = L - M</code> dimensions being assumed to correspond to the <em>columns</em> of the operator.  These dimensions are the size of, respectively, the output and the input arrays when applying the operator.  The parameter <code>N</code> may be specified (although it can be automatically determined):</p><pre><code class="language-none">SparseOperatorCOO{T,M,N}(A[, sel])</code></pre><p>provided the equality <code>M + N = ndims(A)</code> holds.</p><p>A last parameter <code>V</code> can be specified for the type of the vector to store the coefficients of the sparse operator:</p><pre><code class="language-none">SparseOperatorCOO{T,M,N,V}(args...)</code></pre><p>provided <code>V</code> implements standard linear indexing.  The default is to take <code>V = Vector{T}</code>.  As a special case, you can choose a uniform boolean vector from the <code>StructuredArrays</code> package to store the sparse coefficients:</p><pre><code class="language-none">SparseOperatorCOO{T,M,N,UniformVector{Bool}}(args...)</code></pre><p>to get a compressed sparse operator in COO format whose values are an immutable uniform vector of true values requiring no storage.  This is useful to only store the sparse structure of the operator, that is the indices in COO format of the sparse coefficients not their values.</p><p>The <code>SparseOperatorCOO</code> constructor can also be used to convert a sparse operator in another storage format into the COO format.  In that case, parameter <code>T</code> may also be specified to convert the type of the sparse coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L772-L851">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.SparseOperatorCSC" href="#LazyAlgebra.SparseOperators.SparseOperatorCSC"><code>LazyAlgebra.SparseOperators.SparseOperatorCSC</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sparse operators in <em>Compressed Sparse Column</em> (CSC) format store the significant entries in a column-wise order, as a vector of values, a vector of corresponding linear row indices and a vector of offsets indicating, for each column, the range of indices in the vectors of values and of row indices.  This storage format is very suitable for fast application of the operator, notably its adjoint.</p><p>A sparse operator in CSC storage format can be constructed by providing all necessary information:</p><pre><code class="language-none">SparseOperatorCSC(vals, rows, offs, rowsiz, colsiz)</code></pre><p>where <code>vals</code> is the vector of values of the sparse entries, <code>rows</code> is an integer valued vector of the linear row indices of the sparse entries, <code>offs</code> is a column-wise table of offsets in these arrays, <code>rowsiz</code> and <code>colsiz</code> are the sizes of the row and column dimensions.  The entries values and respective linear row indices of the <code>j</code>-th column are given by <code>vals[k]</code> and <code>rows[k]</code> with <code>k ∈ offs[j]+1:offs[j+1]</code>.  The linear column index <code>j</code> is in the range <code>1:n</code> where <code>n = prod(colsiz)</code> is the equivalent number of columns.  For efficiency reasons, sparse operators are currently limited to <em>fast</em> arrays because they can be indexed linearly with no loss of performances.  If <code>vals</code>, <code>rows</code> and/or <code>offs</code> are not fast arrays, they will be automatically converted to linearly indexed arrays.</p><p>A sparse operator in CSC storage format can be directly constructed from a 2-dimensional Julia array <code>A</code>:</p><pre><code class="language-none">SparseOperatorCSC(A, sel = (v,i,j) -&gt; (v != zero(v)))</code></pre><p>where optional argument <code>sel</code> is a selector function which is called as <code>sel(v,i,j)</code> with <code>v</code>, <code>i</code> and <code>j</code> the value, the row and the column linear indices for each entries of <code>A</code> and which is assumed to yield <code>true</code> for the entries of <code>A</code> to be selected in the sparse structure and <code>false</code> for the entries of <code>A</code> to discard.  The default selector is such that all non-zeros of <code>A</code> are selected.</p><p>The element type, say <code>T</code>, for the sparse coefficients can be imposed by rewriting the above examples as:</p><pre><code class="language-none">SparseOperatorCSC{T}(args...)</code></pre><p>A sparse operator in CSC storage format implementing generalized matrix-vector multiplication can also be directly constructed from a <code>L</code>-dimensional Julia array (with <code>L ≥ 2</code>) <code>A</code> by:</p><pre><code class="language-none">SparseOperatorCSC{T,M}(A[, sel])</code></pre><p>with <code>M</code> the number of leading dimensions of <code>A</code> corresponding to the <em>rows</em> of the operator, the trailing <code>N = L - M</code> dimensions being assumed to correspond to the <em>columns</em> of the operator.  These dimensions are the size of, respectively, the output and the input arrays when applying the operator.  The parameter <code>N</code> may be specified (although it can be automatically determined):</p><pre><code class="language-none">SparseOperatorCSC{T,M,N}(A[, sel])</code></pre><p>provided the equality <code>M + N = ndims(A)</code> holds.</p><p>A last parameter <code>V</code> can be specified for the type of the vector to store the coefficients of the sparse operator:</p><pre><code class="language-none">SparseOperatorCSC{T,M,N,V}(args...)</code></pre><p>provided <code>V</code> implements standard linear indexing.  The default is to take <code>V = Vector{T}</code>.  As a special case, you can choose a uniform boolean vector from the <code>StructuredArrays</code> package to store the sparse coefficients:</p><pre><code class="language-none">SparseOperatorCSC{T,M,N,UniformVector{Bool}}(args...)</code></pre><p>to get a compressed sparse operator in CSC format whose values are an immutable uniform vector of true values requiring no storage.  This is useful to only store the sparse structure of the operator, that is the indices in CSC format of the sparse coefficients not their values.</p><p>The <code>SparseOperatorCSC</code> constructor can also be used to convert a sparse operator in another storage format into the CSC format.  In that case, parameter <code>T</code> may also be specified to convert the type of the sparse coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L853-L933">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.SparseOperatorCSR" href="#LazyAlgebra.SparseOperators.SparseOperatorCSR"><code>LazyAlgebra.SparseOperators.SparseOperatorCSR</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Sparse operators in <em>Compressed Sparse Row</em> (CSR) format store the significant entries in a row-wise order, as a vector of values, a vector of corresponding linear column indices and a vector of offsets indicating, for each row, the range of indices in the vectors of values and of column indices.  This storage format is very suitable for fast application of the operator.</p><p>A sparse operator in CSR storage format can be constructed by providing all necessary information:</p><pre><code class="language-none">SparseOperatorCSR(vals, cols, offs, rowsiz, colsiz)</code></pre><p>where <code>vals</code> is the vector of values of the sparse entries, <code>cols</code> is an integer valued vector of the linear column indices of the sparse entries, <code>offs</code> is a column-wise table of offsets in these arrays, <code>rowsiz</code> and <code>colsiz</code> are the sizes of the row and column dimensions.  The entries values and respective linear column indices of the <code>i</code>-th row are given by <code>vals[k]</code> and <code>cols[k]</code> with <code>k ∈ offs[i]+1:offs[i+1]</code>.  The linear row index <code>i</code> is in the range <code>1:m</code> where <code>m = prod(rowsiz)</code> is the equivalent number of rows.  For efficiency reasons, sparse operators are currently limited to <em>fast</em> arrays because they can be indexed linearly with no loss of performances.  If <code>vals</code>, <code>cols</code> and/or <code>offs</code> are not fast arrays, they will be automatically converted to linearly indexed arrays.</p><p>A sparse operator in CSR storage format can be directly constructed from a 2-dimensional Julia array <code>A</code>:</p><pre><code class="language-none">SparseOperatorCSR(A, sel = (v,i,j) -&gt; (v != zero(v)))</code></pre><p>where optional argument <code>sel</code> is a selector function which is called as <code>sel(v,i,j)</code> with <code>v</code>, <code>i</code> and <code>j</code> the value, the row and the column linear indices for each entries of <code>A</code> and which is assumed to yield <code>true</code> for the entries of <code>A</code> to be selected in the sparse structure and <code>false</code> for the entries of <code>A</code> to discard.  The default selector is such that all non-zeros of <code>A</code> are selected.</p><p>The element type, say <code>T</code>, for the sparse coefficients can be imposed by rewriting the above examples as:</p><pre><code class="language-none">SparseOperatorCSR{T}(args...)</code></pre><p>A sparse operator in CSR storage format implementing generalized matrix-vector multiplication can also be directly constructed from a <code>L</code>-dimensional Julia array (with <code>L ≥ 2</code>) <code>A</code> by:</p><pre><code class="language-none">SparseOperatorCSR{T,M}(A[, sel])</code></pre><p>with <code>M</code> the number of leading dimensions of <code>A</code> corresponding to the <em>rows</em> of the operator, the trailing <code>N = L - M</code> dimensions being assumed to correspond to the <em>columns</em> of the operator.  These dimensions are the size of, respectively, the output and the input arrays when applying the operator.  The parameter <code>N</code> may be specified (although it can be automatically determined):</p><pre><code class="language-none">SparseOperatorCSR{T,M,N}(A[, sel])</code></pre><p>provided the equality <code>M + N = ndims(A)</code> holds.</p><p>A last parameter <code>V</code> can be specified for the type of the vector to store the coefficients of the sparse operator:</p><pre><code class="language-none">SparseOperatorCSR{T,M,N,V}(args...)</code></pre><p>provided <code>V</code> implements standard linear indexing.  The default is to take <code>V = Vector{T}</code>.  As a special case, you can choose a uniform boolean vector from the <code>StructuredArrays</code> package to store the sparse coefficients:</p><pre><code class="language-none">SparseOperatorCSR{T,M,N,UniformVector{Bool}}(args...)</code></pre><p>to get a compressed sparse operator in CSR format whose values are an immutable uniform vector of true values requiring no storage.  This is useful to only store the sparse structure of the operator, that is the indices in CSR format of the sparse coefficients not their values.</p><p>The <code>SparseOperatorCSR</code> constructor can also be used to convert a sparse operator in another storage format into the CSR format.  In that case, parameter <code>T</code> may also be specified to convert the type of the sparse coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L935-L1014">source</a></section></article><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.unpack!" href="#LazyAlgebra.SparseOperators.unpack!"><code>LazyAlgebra.SparseOperators.unpack!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unpack!(A, S; flatten=false) -&gt; A</code></pre><p>unpacks the non-zero coefficients of the sparse operator <code>S</code> into the array <code>A</code> and returns <code>A</code>.  Keyword <code>flatten</code> specifies whether to only consider the length of <code>A</code> instead of its dimensions.  In any cases, <code>A</code> must have as many elements as <code>length(S)</code> and standard linear indexing.</p><p>Just call <code>Array(S)</code> to unpack the coefficients of a sparse operator <code>S</code> without providing the destination array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L1410-L1421">source</a></section></article><h3 id="Low-level-interface"><a class="docs-heading-anchor" href="#Low-level-interface">Low-level interface</a><a id="Low-level-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-interface" title="Permalink"></a></h3><p>These methods are provided by <code>using LazyAlgebra.SparseMethods</code>.</p><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.each_row" href="#LazyAlgebra.SparseOperators.each_row"><code>LazyAlgebra.SparseOperators.each_row</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">each_row(A)</code></pre><p>yields an iterator over the linear row indices of the sparse operator <code>A</code> stored in a <em>Compressed Sparse Row</em> (CSR) format, this includes the adjoint of a sparse operator in <em>Compressed Sparse Column</em> (CSC) format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L612-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.each_col" href="#LazyAlgebra.SparseOperators.each_col"><code>LazyAlgebra.SparseOperators.each_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">each_col(A)</code></pre><p>yields an iterator over the linear column indices of the sparse operator <code>A</code> stored in a <em>Compressed Sparse Column</em> (CSC) format, this includes the adjoint of a sparse operator in <em>Compressed Sparse Row</em> (CSR) format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L623-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.each_off" href="#LazyAlgebra.SparseOperators.each_off"><code>LazyAlgebra.SparseOperators.each_off</code></a> — <span class="docstring-category">Function</span></header><section><div><p>For a sparse operator <code>A</code> stored in a <em>Compressed Sparse Coordinate</em> (COO) format, the call:</p><pre><code class="language-none">each_off(A)</code></pre><p>yields an iterator over the indices in the arrays of values and of linear row and column indices for the <code>k</code>-th entry of <code>A</code>.</p><hr/><p>For a sparse operator <code>A</code> stored in a <em>Compressed Sparse Column</em> (CSC) format, the call:</p><pre><code class="language-none">each_off(A, j)</code></pre><p>yields an iterator over the indices in the arrays of values and linear row indices for the <code>j</code>-th column of <code>A</code>.</p><hr/><p>For a sparse operator <code>A</code> stored in a <em>Compressed Sparse Row</em> (CSR) format, the call:</p><pre><code class="language-none">each_off(A, i)</code></pre><p>yields an iterator over the indices in the arrays of values and linear column indices for the <code>i</code>-th row of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L567-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.get_row" href="#LazyAlgebra.SparseOperators.get_row"><code>LazyAlgebra.SparseOperators.get_row</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_row(A, k) -&gt; i</code></pre><p>yields the linear row index of the <code>k</code>-th entry of the sparse operator <code>A</code> stored in a <em>Compressed Sparse Column</em> (CSC) or <em>Coordinate</em> (COO) formats (this includes adjoint of sparse operators in CSR format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L634-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.get_rows" href="#LazyAlgebra.SparseOperators.get_rows"><code>LazyAlgebra.SparseOperators.get_rows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_rows(A)</code></pre><p>yields the row indices of the entries of the sparse operator <code>A</code>.  The returned array may be shared with <code>A</code>, call <code>copy_rows(A)</code> instead if you want to modify the contents of the returned array with no side effects on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L434-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.get_col" href="#LazyAlgebra.SparseOperators.get_col"><code>LazyAlgebra.SparseOperators.get_col</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_col(A, k) -&gt; j</code></pre><p>yields the linear column index of the <code>k</code>-th entry of the sparse operator <code>A</code> stored in a <em>Compressed Sparse Row</em> (CSR) or <em>Coordinate</em> (COO) formats (this includes adjoint of sparse operators in CSC format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L649-L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.get_cols" href="#LazyAlgebra.SparseOperators.get_cols"><code>LazyAlgebra.SparseOperators.get_cols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_cols(A)</code></pre><p>yields the column indices of the entries of the sparse operator <code>A</code>.  The returned array may be shared with <code>A</code>, call <code>copy_cols(A)</code> instead if you want to modify the contents of the returned array with no side effects on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L470-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.get_val" href="#LazyAlgebra.SparseOperators.get_val"><code>LazyAlgebra.SparseOperators.get_val</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_val(A, k) -&gt; v</code></pre><p>yields the value of the <code>k</code>-th entry of the sparse operator <code>A</code> stored in a <em>Compressed Sparse Row</em> (CSR), <em>Compressed Sparse Column</em> (CSC) or <em>Coordinate</em> (COO) format.</p><p>Argument may also be the adjoint of a sparse operator:</p><pre><code class="language-none">get_val(A&#39;, k) -&gt; conj(get_val(A, k))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L665-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.get_vals" href="#LazyAlgebra.SparseOperators.get_vals"><code>LazyAlgebra.SparseOperators.get_vals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_vals(A)</code></pre><p>yields the array storing the values of the sparse operator <code>A</code>.  The returned array is shared with <code>A</code>, call <code>copy_vals(A)</code> instead if you want to modify the contents of the returned array with no side effects on <code>A</code>.</p><p>As a convenience, argument may also be the adjoint of a sparse operator:</p><pre><code class="language-none">get_vals(A&#39;) -&gt; get_vals(A)</code></pre><p>which yields the <strong>unmodified</strong> values of <code>A</code>, hence the caller has to take the conjugate of these values.  The method <code>get_val(A&#39;,k)</code> however takes care of conjugating the values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L401-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.set_val!" href="#LazyAlgebra.SparseOperators.set_val!"><code>LazyAlgebra.SparseOperators.set_val!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_val!(A, k, v) -&gt; v</code></pre><p>assigns <code>v</code> to the value of the <code>k</code>-th entry of the sparse operator <code>A</code> stored in a <em>Compressed Sparse Row</em> (CSR), <em>Compressed Sparse Column</em> (CSC) or <em>Coordinate</em> (COO) format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L681-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.get_offs" href="#LazyAlgebra.SparseOperators.get_offs"><code>LazyAlgebra.SparseOperators.get_offs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_offs(A)</code></pre><p>yields the table of offsets of the sparse operator <code>A</code>.  Not all operators extend this method.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The interpretation of offsets depend on the type of <code>A</code>.  For instance, assuming <code>offs = get_offs(A)</code>, then the index range of the <code>j</code>-th column of a <code>SparseMatrixCSC</code> is <code>offs[j]:(offs[j+1]-1)</code> while the index range is <code>(offs[j]+1):offs[j+1]</code> for a <code>SparseOperatorCSC</code>.  For this reason, it is recommended to call <a href="#LazyAlgebra.SparseOperators.each_off"><code>each_off</code></a> instead or to call <code>get_offs</code> with 2 arguments as shown below.</p></div></div><p>For a transparent usage of the offsets, the method should be called with 2 arguments:</p><pre><code class="language-none">get_offs(A, i) -&gt; k1, k2</code></pre><p>which yields the offsets of the first and last elements in the arrays of values and linear column indices for the <code>i</code>-th row of the sparse operator <code>A</code> stored in a <em>Compressed Sparse Row</em> (CSR) format.  If <code>k2 &lt; k1</code>, it means that the <code>i</code>-th row is empty.  Calling <code>each_off(A,i)</code> directly yields <code>k1:k2</code>.</p><pre><code class="language-none">get_offs(A, j) -&gt; k1, k2</code></pre><p>yields the offsets of the first and last elements in the arrays of values and linear row indices for the <code>j</code>-th column of the sparse operator <code>A</code> stored in a <em>Compressed Sparse Column</em> (CSC) format.  If <code>k2 &lt; k1</code>, it means that the <code>j</code>-th column is empty.  Calling <code>each_off(A,j)</code> directly yields <code>k1:k2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L506-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.copy_rows" href="#LazyAlgebra.SparseOperators.copy_rows"><code>LazyAlgebra.SparseOperators.copy_rows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy_rows(A) -&gt; rows</code></pre><p>yields a copy of the linear row indices of entries in sparse operator <code>A</code>.  The result is a vector that is not shared by <code>A</code>, the caller may thus modify its contents with no side effects on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L448-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.copy_cols" href="#LazyAlgebra.SparseOperators.copy_cols"><code>LazyAlgebra.SparseOperators.copy_cols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy_cols(A) -&gt; cols</code></pre><p>yields a copy of the linear column indices of entries in sparse operator <code>A</code>. The result is a vector that is not shared by <code>A</code>, the caller may thus modify its contents with no side effects on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L484-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LazyAlgebra.SparseOperators.copy_vals" href="#LazyAlgebra.SparseOperators.copy_vals"><code>LazyAlgebra.SparseOperators.copy_vals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">copy_vals([T = eltype(A),] A) -&gt; vals</code></pre><p>yields a copy of the values of the entries in sparse operator <code>A</code> converted to type <code>T</code>.  The result is a vector that is not shared by <code>A</code>, the caller may thus modify its contents with no side effects on <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/LazyAlgebra.jl/blob/ba99fd31c5791d77bf2fd6f3c74a34fe4229b6af/src/sparse.jl#L420-L427">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mappings/">« Methods for mappings</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 12 November 2020 19:26">Thursday 12 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
